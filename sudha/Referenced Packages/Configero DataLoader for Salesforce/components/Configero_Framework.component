<apex:component controller="PowerLoader.Configero_Framework" access="global">
<meta http-equiv="X-UA-Compatible" content="chrome=1" />

<script src="{!URLFOR($Resource.domain_js)}"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min.js" type="text/javascript"></script>
<link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/themes/redmond/jquery-ui.css" />
<script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/jquery-ui.js"></script>
<script src="{!URLFOR($Resource.dhtmlxProAll,'dhtmlx.js')}" type="text/javascript"></script>
<link href="{!URLFOR($Resource.dhtmlxProAll, 'dhtmlx.css')}" rel="STYLESHEET" type="text/css" />

<script src="{!URLFOR($Resource.jquery_toastmessage,'jquery.toastmessage.js')}" type="text/javascript"></script>
<link href="{!URLFOR($Resource.jquery_toastmessage, 'css/jquery.toastmessage.css')}" rel="STYLESHEET" type="text/css" />

<c:Configero_QueryPanelHeaderComponent />

<style>
body .bodyDiv { background-color: transparent; }
.bodyDiv .outerNoSidebar { padding: 0px; }

/* because grid split has it set to 11 - use a high number just to be safe */
.ui-datepicker{ z-index: 9999 !important;}

#criteria, .criteria { width: 100%; height: 100%; overflow: auto }

/* don't put -moz-user-select here since then it makes even regular text inputs disabled in Firefox */
#contentWrapper { -khtml-user-select: none; -webkit-user-select: none; }
#layoutholder, .layoutholder { -khtml-user-select: none; -webkit-user-select: none; }

.dhtmlxcalendar_container.dhtmlxcalendar_skin_dhx_skyblue { background-image: none; background-color: white; border: 2px solid #B1BCC2; }
.dhtmlxcalendar_selectnone_cont { position: relative; display: block; width: 182px; height: 24px; margin-left: 3px; margin-bottom: 3px; }
.dhtmlxcalendar_selectnone_cont li { background-image: url({!URLFOR($Resource.dhtmlxProAll, 'imgs/dhtmlxcalendar_dhx_skyblue/bg_days.png')}); width: 182px; background-position: 0 -24px; background-repeat: no-repeat; color: black; font-size: 11px; line-height: 24px; }

div.error_icon { width: 18px; height: 18px; background-image: url({!URLFOR($Resource.dhtmlxProAll, 'imgs/red.gif')}); background-repeat: no-repeat; }
.dhx_combo_select { z-index: 99999999; }

div.gridbox_dhx_skyblue table.obj tr td { border-width: 0px 1px 0px 0px; border-color: #dedede; border-style: solid; }

div.gridbox_dhx_skyblue table.hdr td { vertical-align: bottom; }

div.gridbox_dhx_skyblue div.ftr td { text-align: left; }

div.gridbox_dhx_skyblue div.ftr .hdrcell input, div.gridbox_dhx_skyblue div.ftr .hdrcell select { width: 100%; font-size: 8pt; font-family: Tahoma; };

div.gridbox_dhx_skyblue div.ftr .hdrcell img { cursor: pointer; }
div.gridbox_dhx_skyblue div.ftr .hdrcell td { white-space: nowrap; border: 0px; padding: 0px; }
div.gridbox_dhx_skyblue div.ftr .hdrcell > table { width: 100%; border: 0px; padding: 0px; }
div.gridbox_dhx_skyblue div.ftr .hdrcell > input[type="text"], div.gridbox_dhx_skyblue div.ftr .hdrcell > select { width: 90%; }

div.gridbox table.obj { border-bottom: 1px solid #dedede; }
div.gridbox td.changed_flag { font-weight: bold !important; background-image: url({!URLFOR($Resource.dhtmlxProAll, 'custom/sky_blue_mod.png')}) !important; }
div.gridbox td.errored_flag { background-image: url({!URLFOR($Resource.dhtmlxProAll, 'custom/sky_blue_err.png')}) !important; }

.hidden { display: none; }
</style>

<script>
/**** TEMPORARY ****/
if (!document.body.attachEvent) {
	document.body.attachEvent = function(typ, func) {
		document.body.addEventListener(typ.substring(2), func, true);
	};
}
if (!document.body.detachEvent) {
	document.body.detachEvent = function(typ, func) {
		document.body.removeEventListener(typ.substring(2), func, false);
	};
}
/*** ALSO - attachScheduler in dhtmlXContainer ***/
/*dhtmlXGridObject.prototype.startFastOperations = function() {};
dhtmlXGridObject.prototype.stopFastOperations = function() {};
dhtmlXTabBar.prototype.getAllTabs = function() {
    var a = [], b;
    for (b in this._tabs)
        a.push(b);
    return a
};*/
</script>

<script>
var CF_HOSTED_URL = '';
var CF_SF_SUBDOMAIN = '';
var CF_NAMESPACE_PREFIX = '';
{
    var host_prefix = '';
    var tmp_ss = '{!$RemoteAction.Configero_Framework.savePagePreferences}'.split('.');
    if (tmp_ss.length == 2) {
        // no namespace
        host_prefix = 'c';
    } else {
        CF_NAMESPACE_PREFIX = tmp_ss[0] + '__';
        host_prefix = tmp_ss[0].toLocaleLowerCase();
    }
    {
	    var host = window.location.host.split('.')[0];
    	var subdind = host.lastIndexOf('--');
    	if (subdind >= 0) {
    		host_prefix = host.substring(0, subdind) + '--' + host_prefix;
    	}
    }
    CF_HOSTED_URL = window.location.protocol + "//" + host_prefix + '.' + document.domain;
}

// globals
var CF_currentKeysPressed = {};
var CF_totalProgressWindows = 0;
var CF_progressCompleteQueue = []; // functions to run after progress is finished
var LOAD_PAGE_SIZE = 250;
var SAVE_PAGE_SIZE = 50;
var lastIdBatch = []; // keeps track of the IDs that have been sent in the last request in case of errors
dhtmlx.image_path = "{!URLFOR($Resource.dhtmlxProAll, 'imgs/')}";

$(document).keydown(function(e) {
    CF_currentKeysPressed[e.which] = 1;
}).keyup(function(e) {
    delete CF_currentKeysPressed[e.which];
});

/************** MISC FUNCS *******************************/
if (typeof String.prototype.beginsWith != 'function') {
    String.prototype.beginsWith = function(a) {
        return this.indexOf(a) === 0;
    };
}
if (typeof String.prototype.endsWith != 'function') {
    String.prototype.endsWith = function(a) {
        return this.indexOf(a, this.length - a.length) !== -1;
    };
}
Date.prototype.setISO8601 = function (string) {
    var regexp = "([0-9]{4})(-([0-9]{2})(-([0-9]{2})" +
        "(T([0-9]{2}):([0-9]{2})(:([0-9]{2})(\.([0-9]+))?)?" +
        "(Z|(([-+])([0-9]{2}):([0-9]{2})))?)?)?)?";

	// sanity check - make sure it's got a "-" in there somewhere...do we care about just the year?
    if (string.indexOf('-') != 4) string = undefined; // force an exception to be thrown

    var d = string.match(new RegExp(regexp));

    var offset = 0;
    var date = new Date(d[1], 0, 1);

    if (d[3]) { date.setMonth(d[3] - 1); }
    if (d[5]) { date.setDate(d[5]); }
    if (d[7]) { date.setHours(d[7]); }
    if (d[8]) { date.setMinutes(d[8]); }
    if (d[10]) { date.setSeconds(d[10]); }
    if (d[12]) { date.setMilliseconds(Number("0." + d[12]) * 1000); }
    if (d[14]) {
        offset = (Number(d[16]) * 60) + Number(d[17]);
        offset *= ((d[15] == '-') ? 1 : -1);

        // changed - only do offset IF we have an offset passed in - otherwise assume it's local timezone
        offset -= date.getTimezoneOffset();
    } else if (d[7]) {
    	// we got time but no timezone offset - set it for the current user timezone
    	offset = 60 * {!currentTimezoneOffset};
    }
    time = (Number(date) + (offset * 60 * 1000));
    this.setTime(Number(time));
}

/************** CUSTOM CELLS *****************************/
eXcell.prototype.getPlainValue = function(type) {
    var v = this.getValue();
    if (type == 'tree') {
        v = $.unescapeHTML(v);
    }
    return v;
}

// return title tooltip when available
eXcell_link.prototype.getTitle = function() {
    var a = this.cell.firstChild;
    return a && a.tagName ? (a.getAttribute('title') ? a.getAttribute('title') : a.getAttribute("href")) : ""
};

// blank cell for groups - ignores all values
function eXcell_blank(a) {
    this.cell = a;
    this.edit = function() {
    };
    this.isDisabled = function() {
        return !0
    };
    this.getValue = function() {
        return '';
    };
    this.setValue = function(a) {
    	this.cell._clearCell = !0;
        this.cell.innerHTML = '';
    }
}
eXcell_blank.prototype = new eXcell;

// readonly (disabled) rotxt
function eXcell_corotxt_ro(a) {
    this.base = eXcell_corotxt;
    this.base(a);
    this.edit = function() {
    };
    this.isDisabled = function() {
        return !0
    };
}
eXcell_corotxt_ro.prototype = new eXcell_corotxt;

// to fix an issue where if you blank out a cell before the split, if you do a sort or filter, it gets replaced by a space
function eXcell_edtxt(a) {
    if (a) this.cell = a, this.grid = this.cell.parentNode.grid;
    this.getValue = function() {
        if (this.cell.firstChild && this.cell.atag && this.cell.firstChild.tagName == this.cell.atag) {
            return this.cell.firstChild.value;
        } else {
            if (this.cell._clearCell) return '';
            var ret = _isIE ? $(this.cell).text() : this.cell.textContent;
            if (ret == ' ') return '';
            return ret;
        }
    };
    this.setValue = function(a) {
        !a || a.toString()._dhx_trim() == "" ? (a = " ", this.cell._clearCell = !0) : this.cell._clearCell = !1;
        this.setCTxtValue(a)
    }
}
eXcell_edtxt.prototype = new eXcell_ed;

// fixes an issue where 0 doesn't get formatted per numberFormat
eXcell_ron.prototype.setValue = function(a) {
    if (a !== 0 && (!a || a.toString()._dhx_trim() == ""))
        return this.setCValue("&nbsp;"), this.cell._clearCell = !0;
    this.cell._clearCell = !1;
    this.setCValue(a ? this.grid._aplNF(a, this.cell._cellIndex) : this.grid._aplNF('0', this.cell._cellIndex))
};
eXcell_edn.prototype.setValue = function(a) {
    if (a !== 0 && (!a || a.toString()._dhx_trim() == ""))
        return this.cell._clearCell = !0, this.setCValue("&nbsp;", 0);
    else
        this.cell._clearCell = !1, this.cell._orig_value = a;
    this.setCValue(this.grid._aplNF(a, this.cell._cellIndex), a)
};

function eXcell_err(a) {
    try {
        this.cell = a;  this.grid = this.cell.parentNode.grid;
    } catch(b) {}
    this.getValue = function() {
        var ret = $('.error_icon', $(this.cell)).attr('title');
        if (ret == undefined) ret = '';
        return ret;
    }
    this.isDisabled = function() { return !0; }
}

eXcell_err.prototype = new eXcell;
eXcell_err.prototype.getTitle = function() { return this.getValue(); }
eXcell_err.prototype.setValue = function(a) {
    if (a == undefined || a == null || a == '') this.setCValue('');
    else {
        var d = $('<div />');
        var err = $('<div class="error_icon" />');
        d.append(err);
        err.attr('title', a);
        this.setCValue(d.html());
    }
}

function eXcell_chro(cell) {
    this.cell = cell;
    this.edit = function() {}
    this.setValue = function(a) {
      this.cell.innerHTML = '<img val="' + a + '" src="/img/checkbox_' + (a == '0' ? 'un' : '') + 'checked.gif">';
    }
    this.getValue = function() { return $('img', $(this.cell)).attr('val'); }
}
eXcell_chro.prototype=new eXcell;

function eXcell_lkup(cell) {
    this.cell = cell;
    this.setValue = function(a) {
      var ind = $(this.cell).index();
      var idd = this.cell.parentNode.idd;
      var g = this.cell.parentNode.grid.CF_getRealGrid();
      while ($.isGroupId(idd)) {
      	// get the value from the first child
      	if (g._h2.get[idd].childs.length == 0) {
      		// we're just creating this group as a result of a group edit + move ... no child yet - proceed with just the text for now
      		this.cell.innerHTML = '<a>' + $.escapeHTML(a) + '</a>';
      		return;
      	} else {
      		idd = g._h2.get[idd].childs[0].id;
      	}
      }
      var orig_rid = (idd.split('_'))[0];
      var ida = g.CF_getUserData(orig_rid, g.CF_fieldDef[ind].field);
      this.cell.innerHTML = '<a href="/' + ida + '" target="_blank">' + $.escapeHTML(a) + '</a>';
    }
    this.getValue = function() { return $('a', $(this.cell)).text(); }
}
eXcell_lkup.prototype=new eXcell;



// lookup combo with search option
function eXcell_lkupcombo(cell) {
    var ret = new eXcell_combo(cell);
	ret.edit = function() {
		if (!window.dhx_globalImgPath) window.dhx_globalImgPath = this.grid.imgURL;
        this.val = this.getValue();
        var a = this.getText();
        this.cell._clearCell && (a = "");
        this.cell.innerHTML = "";
        this.combo = this.cell._brval ? this.cell._brval : (this.grid._realfake ? this.grid._fake : this.grid)._col_combos[this.cell._cellIndex];
        this.combo._lasttext = false;
        this.cell.appendChild(this.combo.DOMParent);
        this.combo.DOMParent.style.margin = "0";
        this.combo.DOMelem_input.focus();
        this.combo.setSize(this.cell.offsetWidth - 2);
        this.combo.setComboText(a);

        var g = this.grid.CF_getRealGrid();
        var ida = g.CF_getUserData(this.cell.parentNode.idd, g.CF_fieldDef[this.cell._cellIndex].field);
        this.combo.DOMelem_hidden_input.value = a;
        this.combo.DOMelem_hidden_input2.value = ida;

        this.combo.openSelect();
    }
    ret.setValue = function(a) {
		var ind = this.cell._cellIndex;
      	var idd = this.cell.parentNode.idd;
      	var g = this.grid.CF_getRealGrid();
      	while ($.isGroupId(idd)) {
      		// get the value from the first child
      		if (g._h2.get[idd].childs.length == 0) {
      			// we're just creating this group as a result of a group edit + move ... no child yet - proceed with just the text for now
      			this.cell.innerHTML = '<a>' + $.escapeHTML(a) + '</a>';
      			return;
      		} else {
      			idd = g._h2.get[idd].childs[0].id;
      		}
      	}
      	var orig_rid = (idd.split('_'))[0];
      	var ida = g.CF_getUserData(orig_rid, g.CF_fieldDef[ind].field);
      	this.setCValue('<a href="/' + ida + '" target="_blank">' + $.escapeHTML(a) + '</a>');
    }
    ret.getValue = function() { return $('a', $(this.cell)).text(); }
    ret.detach = function() {
		var ind = this.cell._cellIndex;
    	var g = this.grid.CF_getRealGrid();
        var ida = g.CF_getUserData(this.cell.parentNode.idd, g.CF_fieldDef[ind].field);

        this.cell.removeChild(this.combo.DOMParent);
        this.combo._confirmSelection();
        var newVal = this.combo.DOMelem_hidden_input2.value;
        g.setUserData(this.cell.parentNode.idd, g.CF_fieldDef[ind].field, newVal);
        this.setValue(this.combo.getComboText());

        this.combo.closeAll();
        this.grid._still_active = !0;
        this.grid.setActive(1);
        return ida != newVal;
    }
    return ret;
}
dhtmlXCombo.prototype._fetchOptions = function(a, b) {
	if (b === this._lasttext) return; // prevents an infinite loop

    if (b == "") {
    	this.clearAll();
        this._addOption({text: "Search...", value: 'X'});
        this.render(true);
        return;
    }
    var c = false;
    if (typeof this._xml == 'string') {
    	c = this._xml + (this._xml.indexOf("?") != -1 ? "&" : "?") + "pos=" + a + "&mask=" + encodeURIComponent(b);
    } else {
    	c = this._xml.apply(this, [b]);
    }
    this._lasttext = b;
    this._load ? this._load = c : this.callEvent("onDynXLS", [b, a]) && this.loadXML(c)
};
dhtmlXCombo.prototype.CF_getLookupAutoCompleteFunc = function(a) {
	return {!$RemoteAction.Configero_Framework.getLookupAutocomplete};
}
dhtmlXCombo.prototype.loadXML = function(a, b) {
    this._load = !0;
    this.callEvent("onXLS", []);
    if (this._prs)
        for (var c = 0; c < this._prs.length; c++)
            a += [getUrlSymbol(a), escape(this._prs[c][0]), "=", escape(this._prs[c][1])].join("");

	var rep = a;
	if (typeof a != 'string') {
		rep = JSON.stringify(a);
	}

    if (this._xmlCache && this._xmlCache[rep])
        this._fillFromXML(this, null, null, null, this._xmlCache[rep]), b && b();
    else {
    	var that = this;
    	this.CF_getLookupAutoCompleteFunc(a)(a, function(result, event) {
	        if (result) {
	        	var doc = $.parseXML(result);
	        	var x = new dtmlXMLLoaderObject();
	        	x.xmlDoc = {responseXML: doc, responseText: result};
	        	x._cPath = rep;
	        	that._fillFromXML(that, null, null, null, x);
	        }
	   }, {escape: false});
    }
};
dhtmlXCombo.prototype._fillFromXML = function(a, b, c, d, e) {
    a._xmlCache && (a._xmlCache[e._cPath] = e);
    var f = e.getXMLTopNode("complete");
    if (f.tagName != "complete")
        a._load = !1;
    else {
        var g = e.doXPath("//complete"), h = e.doXPath("//option"), i = !1;
        a.render(!1);
        if (!g[0] || !g[0].getAttribute("add")) {
            if (a.clearAll(), a._lastLength = h.length, a._xml)
                if (!h || !h.length)
                    a.closeAll();
                else if (a._activeMode)
                    a._positList(), a.DOMlist.style.display = "block", _isIE && a._IEFix(!0)
        } else
            a._lastLength += h.length || Infinity, i = !0;
        for (var j = 0; j < h.length; j++) {
            var k = {};
            k.text = h[j].firstChild ? h[j].firstChild.nodeValue : "";
            for (var m = 0; m < h[j].attributes.length; m++) {
                var l = h[j].attributes[m];
                if (l)
                    k[l.nodeName] = l.nodeValue
            }
            a._addOption(k)
        }
	    a._addOption({text: "Search...", value: 'X'});

        a.render(true); //i != !0 || !!h.length);

        var n = e.doXPath("//option[@selected]");
        a._load && a._load !== !0 ? a.loadXML(a._load) : (a._load = !1, !a._lkmode && a._filter && !a._autoDisabled && (!n.length && h.length && a._correctSelection()));
        n.length && a.selectOption(a.getIndexByValue(n[0].getAttribute("value")), !1, !0);
        a.callEvent("onXLE", [])
    }
};
dhtmlXCombo_defaultOption.prototype.render = function() {
    if (!this.content) {
        this.content = document.createElement("DIV");
        this.content._self = this;
        this.content.style.cssText = "width:100%; overflow:hidden;" + this.css;
        if (_isOpera || _isKHTML)
            this.content.style.padding = "2px 0px 2px 0px";
        $(this.content).text(this.text);
        this._ctext = typeof this.content.textContent != "undefined" ? this.content.textContent : this.content.innerText
    }
    return this.content
};
dhtmlXCombo.prototype._correctSelection = function() {
    if (this.getComboText() != "")
        for (var a = 0; a < this.optionsArr.length; a++)
            if (!this.optionsArr[a].isHidden())
                return this.selectOption(a, !0, !1);
    this.unSelectOption()
};
dhtmlXCombo.prototype._confirmSelection = function(a, b) {
    var c = this.getComboText();
    this.setComboText('');
    if (c == '') {
        // nothing picked - clear it out
        this.DOMelem_hidden_input.value = '';
        this.DOMelem_hidden_input2.value = '';
    } else if (this._selOption && this._selOption.text == c && this._selOption.value != 'X') {
        // something selected _selOption.value
        this.setComboText(this._selOption.text);
        this.DOMelem_hidden_input.value = this._selOption.text;
        this.DOMelem_hidden_input2.value = this._selOption.value;
    } else {
    	// revert
    	this.setComboText(this.DOMelem_hidden_input.value);
        if (this._selOption && this._selOption.value == 'X') {
        	// pop up lookup
        	var that = this;
        	if (this.CF_VFTimer) window.clearTimeout(this.CF_VFTimer);
        	this.CF_VFTimer = window.setTimeout(function() {
        		// end the edit
        		that.setComboText(that.DOMelem_hidden_input.value);
        		that.unSelectOption();
        		that.callEvent("onKeyPressed", [13]);
        		that.callEvent("CF_VFLookup", []);
        	}, 1);
        }
    }
    if(arguments.length==0) {
        return this._skipFocus=!1;
    }
    if(!this._skipFocus&&!this._disabled)
        try{this.DOMelem_input.focus()}catch(e){}
    this._skipFocus=!1;
    this.callEvent("onChange", []);
    this._activeMode=!1;
}
// updated to filter out everything except the last item (which is the Search option)
dhtmlXCombo.prototype.filterSelf = function(a) {
    var b = this.getComboText();
    if (this._xml)
        this._lkmode = a, this._fetchOptions(0, b);
    var c = b.toLocaleLowerCase();
    //var c = RegExp("([" + this.filterEntities.join("\\") + "])", "g"), b = b.replace(c, "\\$1"), d = (this._anyPosition ? "" : "^") + b, e = RegExp(d, "i");
    this.filterAny = !1;
    for (var f = 0; f < this.optionsArr.length - 1; f++) {
    	var g = this.optionsArr[f].text.toLocaleLowerCase().beginsWith(c);
        //var g = e.test(this.optionsArr[f].content ? this.optionsArr[f].data()[1] : this.optionsArr[f].text);
        this.filterAny |= g;
        this.optionsArr[f].hide(!g)
    }
    if (this.optionsArr.length == 1) {
    	// only option is search
    	this.filterAny = true;
    }
    this.filterAny ? (this.DOMlist.style.display != "block" &&
    this.openSelect(), _isIE && this._IEFix(!0)) : (this.closeAll(), this._activeMode = !0);
    !a && !this._autoDisabled ? true : this.unSelectOption()
};




function eXcell_lkupro(cell) {
    this.cell = cell;
    this.edit = function() {}
	this.isDisabled=function(){return true;} 
}
eXcell_lkupro.prototype=new eXcell_lkup;

function eXcell_lkupnolink(cell) {
    this.cell = cell;
    this.setValue = function(a) {
      var ind = $(this.cell).index();
      var idd = this.cell.parentNode.idd;
      var g = this.cell.parentNode.grid.CF_getRealGrid();
      while ($.isGroupId(idd)) {
      	// get the value from the first child
      	if (g._h2.get[idd].childs.length == 0) {
      		// we're just creating this group as a result of a group edit + move ... no child yet - proceed with just the text for now
      		this.cell.innerHTML = $.escapeHTML(a);
      		return;
      	} else {
      		idd = g._h2.get[idd].childs[0].id;
      	}
      }
      var orig_rid = (idd.split('_'))[0];
      var ida = g.CF_getUserData(orig_rid, g.CF_fieldDef[ind].field);
      this.cell.innerHTML = $.escapeHTML(a);
    }
    this.getValue = function() { return $(this.cell).text(); }
}
eXcell_lkupnolink.prototype=new eXcell_lkup;

function eXcell_lkupnolinkro(cell) {
    this.cell = cell;
    this.edit = function() {}
	this.isDisabled=function(){return true;} 
}
eXcell_lkupnolinkro.prototype=new eXcell_lkupnolink;

function eXcell_vf(a){
    if (a)
        this.cell = a, this.grid = this.cell.parentNode.grid;
    this.edit = function() {
        this.grid.editStop();
        this.grid.CF_beginVFEdit(this.cell.parentNode.idd, this.cell._cellIndex);
        return false;
    };
    this.detach = function() {
        // do nothing
        return false;
    }
}
eXcell_vf.prototype=new eXcell_edtxt;

function eXcell_plvf(a) {
    this.base = eXcell_corotxt;
    this.base(a);
    this.edit = function() {
        this.grid.editStop();
        this.grid.CF_beginVFEdit(this.cell.parentNode.idd, this.cell._cellIndex);
        return false;
    };
    this.detach = function() {
        // do nothing
        return false;
    }
}
eXcell_plvf.prototype = new eXcell_corotxt;

function eXcell_edtxtvf(a) {
    this.base = eXcell_edtxt;
    this.base(a);
    this.edit = function() {
        this.grid.editStop();
        this.grid.CF_beginVFEdit(this.cell.parentNode.idd, this.cell._cellIndex);
        return false;
    };
    this.detach = function() {
        // do nothing
        return false;
    }
}
eXcell_edtxtvf.prototype = new eXcell_edtxt;

function eXcell_chvf(cell) {
    if (cell) this.cell = cell; this.grid = this.cell.parentNode.grid;
    this.changeState = function(a) {
        a === !0 && !this.grid.isActive && (window.globalActiveDHTMLGridObject != null && window.globalActiveDHTMLGridObject != this.grid && window.globalActiveDHTMLGridObject.isActive && 
        window.globalActiveDHTMLGridObject.setActive(!1), this.grid.setActive(!0));
        if (this.grid.isEditable && !this.cell.parentNode._locked && !this.isDisabled())
            this.grid.CF_beginVFEdit(this.cell.parentNode.idd, this.cell._cellIndex);
    };
}
eXcell_chvf.prototype=new eXcell_ch;
eXcell_chvf.prototype.setValue = function(a) {
    this.cell.style.verticalAlign = "middle";
    if (a && (a = a.toString()._dhx_trim(), a == 'false' || a == '0')) a = '';
    a = a ? '1' : '0';
    this.cell.chstate = a;
    var b = this;
    this.setCValue("<img src='" + this.grid.imgURL + "item_chk" + a + ".gif' onclick='new eXcell_chvf(this.parentNode).changeState(true); (arguments[0]||event).cancelBubble=true; '>", this.cell.chstate);
}

/*** date time cell ***/
function eXcell_CF_dhxCalendarTime(a) {
    if (a && (this.cell = a, this.grid = this.cell.parentNode.grid, !this.grid._grid_calendarCFTime)) {
        var b = this.grid._grid_calendarCFTime = new dhtmlxCalendarObject();
        this.grid.callEvent("onDhxCalendarCreated", [b, this.grid.CF_fieldDef[this.cell._cellIndex]['type'] == 'CF_dhxCalendarTime']);
        var c = this.grid;
        b.attachEvent("onClick", function() {
            this._last_operation_calendar = !0;
            window.setTimeout(function() {
                c.editStop()
            }, 1);
            return !0
        });
        var d = function(a) {
            (a || event).cancelBubble = !0
        };
        dhtmlxEvent(b.base, "click", d)
    }
}
eXcell_CF_dhxCalendarTime.prototype = new eXcell;
eXcell_CF_dhxCalendarTime.prototype.edit = function() {
    var a = this.grid.getPosition(this.cell);
    this.grid._grid_calendarCFTime._show(!1, !1);
    this.grid._grid_calendarCFTime.setPosition(a[0] * 1 + this.cell.offsetWidth, a[1] * 1);
    this.grid.callEvent("onCalendarShow", [this.grid._grid_calendarCFTime, this.cell.parentNode.idd, this.cell._cellIndex]);
    this.grid._grid_calendarCFTime._last_operation_calendar = !1;
    this.cell._cediton = !0;
    this.val = this.cell.val;
    this._val = this.cell.innerHTML;
    var b = this.grid._grid_calendarCFTime.draw;
    this.grid._grid_calendarCFTime.draw = function() {};
    this.grid._grid_calendarCFTime.setDateFormat(this.grid.CF_getDateFormat() + " %h:%i %a");
    this.grid._grid_calendarCFTime.setDate(this.val);
    this.grid._grid_calendarCFTime.draw = b;
    this.grid._grid_calendarCFTime.draw();
    this.cell.atag = !this.grid.multiLine && (_isKHTML || _isMacOS || _isFF) ? "INPUT" : "TEXTAREA";
    this.obj = document.createElement(this.cell.atag);
    this.obj.style.height = this.cell.offsetHeight - (_isIE ? 4 : 2) + "px";
    this.obj.className = "dhx_combo_edit";
    this.obj.wrap = "soft";
    this.obj.style.textAlign = this.cell.align;
    this.obj.onclick = function(a) { (a || event).cancelBubble = !0 };
    this.obj.onmousedown = function(a) { (a || event).cancelBubble = !0 };
    this.obj.value = this.getValue();
    this.cell.innerHTML = "";
    this.cell.appendChild(this.obj);
    if (_isFF && (this.obj.style.overflow = "visible", this.grid.multiLine && this.obj.offsetHeight >= 18 && this.obj.offsetHeight < 40))
        this.obj.style.height = "36px", this.obj.style.overflow = "scroll";
    this.obj.onselectstart = function(a) {
        a || (a = event);
        return a.cancelBubble = !0
    };
    this.obj.focus();
    this.obj.focus()
};
eXcell_CF_dhxCalendarTime.prototype.getDate = function() {
    return this.cell.val ? this.cell.val : null
};
eXcell_CF_dhxCalendarTime.prototype.getValue = function() {
    return this.cell._clearCell ? "" : this.cell.innerHTML.toString()._dhx_trim()
};
eXcell_CF_dhxCalendarTime.prototype.detach = function() {
    if (this.grid._grid_calendarCFTime && (this.grid._grid_calendarCFTime.hide(), this.cell._cediton)) {
        this.cell._cediton = !1;
        if (this.grid._grid_calendarCFTime._last_operation_calendar) {
            this.grid._grid_calendarCFTime._last_operation_calendar = !1;
            var a = this.grid._grid_calendarCFTime.getFormatedDate(this.grid.CF_getDateFormat() + " %h:%i %a"), b = this.grid._grid_calendarCFTime.getDate();
            this.cell.val = new Date(b);
            this.setCValue(a, b);
            this.cell._clearCell = !a;
            var c = this.val;
            this.val = this._val;
            return this.cell.val.valueOf() != 
            (c | 0).valueOf()
        }
        this.setValue(this.obj.value);
        c = this.val;
        this.val = this._val;
        return this.cell.val.valueOf() != (c || "").valueOf()
    }
};
eXcell_CF_dhxCalendarTime.prototype.setValue = function(a) {
    a && typeof a == "object" ? (this.cell.val = a, this.cell._clearCell = !1, this.setCValue(this.grid._grid_calendarCFTime.getFormatedDate(this.grid.CF_getDateFormat() + " %h:%i %a", a).toString(), this.cell.val)) : (!a || a.toString()._dhx_trim() == "" ? (a = "&nbsp", this.cell._clearCell = !0, this.cell.val = "") : (this.cell._clearCell = !1, this.cell.val = new Date(this.grid._grid_calendarCFTime.setFormatedDate(this.grid.CF_getDateFormat() + " %h:%i %a", a.toString(), null, !0))), this.cell.val == "NaN" || this.cell.val == "Invalid Date" ? (this.cell.val = new Date, this.cell._clearCell = !0, this.setCValue("&nbsp;", 0)) : this.setCValue((a || "").toString(), this.cell.val))
};

/********** DRAG/DROP FUNCS ********/
dragContext.prototype.uid = function() {
    this.nid = this.sid;
    if (this.tobj.rowsAr[this.nid]) this.nid = this.sid + '_' + (new Date()).getTime();
    return this;
}

/********** TOOLBAR FUNCS **********/
dhtmlXToolbarObject.prototype.hasItem = function(idd) {
	return idd ? this.objPull[this.idPrefix + idd] : false;
}

/********** TABBAR FUNCS ***********/
dhtmlXTabBar.prototype.CF_destroy = function() {
   var tabs = this.getAllTabs();
   for (var i = 0; i < tabs.length; i++) {
       var tb = window[tabs[i]];
       if (tb && tb.CF_destroy) tb.CF_destroy();
   }
}

/********** MENU FUNCS *************/
dhtmlXMenuObject.prototype.CF_getUserData = function(a, b) {
    return this.getUserData(a, b);
}

/********** TREE FUNCS *************/
dhtmlXTreeObject.prototype.CF_getUserData = function(a, b) {
    return this.getUserData(a, b);
}
dhtmlXTreeObject.prototype.CF_genericSFLoadFunc = function(grouper, result, event, opts) {
   if (event.status == true) {
     opts = opts || {};
     var ids = false;
     eval('ids = ' + result.ids);
     eval('result = ' + result.results);
     var rhash = {};
     // go through and reset the results array in the order of ids
     for (var i = 0; i < result.length; i++) {
        rhash[result[i].Id] = result[i];
     }
     result = [];
     for (var i = 0; i < ids.length; i++) {
        result.push(rhash[ids[i]]);
     }

     var disp = {id: 0, item: []};
     var childrenByParent = {};
     var recArr = [];
     var userData = {};
     for (var i = 0; i < result.length; i++) {
         if (!childrenByParent[result[i].Id]) childrenByParent[result[i].Id] = [];
         var rec = {id: result[i].Id, text: result[i].Name, item: childrenByParent[result[i].Id]};
         if (!result[i][grouper] || result[i][grouper] == '') {
             // root element - can be multiple
             disp['item'].push(rec);
         } else {
             // has a parent - add this one to the parent
             if (!childrenByParent[result[i][grouper]]) childrenByParent[result[i][grouper]] = [];
             childrenByParent[result[i][grouper]].push(rec);
         }
         if (opts['userdata']) {
            userData[rec.id] = opts['userdata'](result[i]);
         }
         recArr.push(rec);
     }
     for (var i = 0; i < recArr.length; i++) {
         if (recArr[i].item.length == 0) delete recArr[i].item;
     }
     this.loadJSONObject(disp);
     for (var i in userData) {
        if (!userData[i]) continue;
        for (var key in userData[i]) {
           this.setUserData(i, key, userData[i][key]);
        }
     }
   } else {
     // an anomoly occurred - show the error to the user
     // TODO - do we need to disable things when an error occurs (like if grid doesn't load, hide toolbar)?
     alert(event.message);
   }
   CF_endProgress();
}

/************** DHTMLX FUNCS *****************************/
// get rid of dhtmlXWindows - layout initializes it automatically (since it's included in pro) - we don't want layouts to be tied to this - it messes up styles on document.body
window.dhtmlXWindows = false;

// bug fix
var dhtmlXContainer_override = dhtmlXContainer;
dhtmlXContainer = function(a) {
    var ret = new dhtmlXContainer_override(a);
    var o = ret.obj;
/*
    a.attachScheduler = function(a, b, c) {
        if (c)
            g = document.getElementById(c);
        else {
            var g = document.createElement("DIV");
            g.id = "dhxSchedObj_" + this._genStr(12);
            g.innerHTML = '<div id="' + g.id + '" class="dhx_cal_container" style="width:100%; height:100%;"><div class="dhx_cal_navline"><div class="dhx_cal_prev_button">&nbsp;</div><div class="dhx_cal_next_button">&nbsp;</div><div class="dhx_cal_today_button"></div><div class="dhx_cal_date"></div><div class="dhx_cal_tab" name="day_tab" style="right:204px;"></div><div class="dhx_cal_tab" name="week_tab" style="right:140px;"></div><div class="dhx_cal_tab" name="month_tab" style="right:76px;"></div></div><div class="dhx_cal_header"></div><div class="dhx_cal_data"></div></div>';
            document.body.appendChild(g.firstChild)
        }
        this.attachObject(g.id, !1, !0);
        this.vs[this.av].sched = scheduler;
        this.vs[this.av].schedId = g.id;
        scheduler.setSizes = scheduler.update_view;
        scheduler.destructor = function() {
        };
        scheduler.init(g.id, a, b);
        return this.vs[this._viewRestore()].sched;
    }; 
*/
    o.updateNestedObjects_override = o.updateNestedObjects;
    o.updateNestedObjects = function() {
        // certain versions of dhtmlx fail in the setsizes method since the child sometimes doesn't exist yet - we try/catch it
        o.updateNestedObjects_override();
        o.vs[o.av].grid && o.vs[o.av].grid._fake && o.vs[o.av].grid._fake._correctSplit();
    }
    return ret;
};

// bug fix in dhtmlxtab for IE8 where setting the background first causes the secure/unsecure warning to come up
// to reproduce, load the grid or minigrid with the right hand properties window minimized
dhtmlXTabBar.prototype._img = function(a, b, c, d, e) {
	if (typeof a != "undefined")
    	a.style.backgroundPosition = this._get_img_pos(b), a.style[this._py] = "0px", c && (a.style[this._dx] = Math.max(d, 0) + "px", a.style[c] = (e || 0) + "px"), a.style.backgroundImage = "url(" + this.imgUrl + this.skin + "/" + this.skin + "_" + this._s.mode + ".gif)"
};


/************** GRID OVERRIDE FUNCS **********************/
dhtmlXGridObject.prototype.CF_isInGroupMode = function() {
	return this.CF_groupFields;
}
dhtmlXGridObject.prototype.CF_destroy = function() {
    this.CF_resetRequeryTimer();
    var g = this;
    window.setTimeout(function() {
    	g.destructor();

    	// set CF_destroy and setSizes back on there just in case something else calls it (like nested layout, tabs, etc)
    	g.CF_destroy = g.setSizes = function() { };
    }, 0);
}
dhtmlXGridObject.prototype.CF_clearSelection = function() {
    this.clearSelection();
    if (this._fake) this._fake.clearSelection();
    this.callEvent('onRowSelect', ['', 0]);
}
dhtmlXGridObject.prototype.CF_beginRequeryTimer = function() {
    this.CF_resetRequeryTimer();
    if (this.CF_lastRequeryTs && this.CF_pollNewRecFunc) {
        var that = this;
        this.CF_newRecPollTimer = window.setTimeout(function() {
            if (!that.CF_lastRequeryTs) return;
            that.CF_pollNewRecFunc(that.CF_lastRequeryTs, function(result, event) {
                that.CF_beginRequeryTimer();
                if (event.status == true) {
                    that.CF_lastRequeryTs = result['ts'];
                } else {
                    // ignore error???
                }
            });
        }, 15000);
    }
}
dhtmlXGridObject.prototype._in_header_tooltip=function(tag,index,data){
   $(tag).text(data[0]).append(' ').append($('<img src="/s.gif" class="helpIcon" />').attr('title', this.CF_getRealGrid().CF_fieldDef[index]['helpText']));
}
dhtmlXGridObject.prototype.CF_resetRequeryTimer = function() {
    if (this.CF_newRecPollTimer) window.clearTimeout(this.CF_newRecPollTimer);
    this.CF_newRecPollTimer = false;
}
dhtmlXGridObject.prototype.CF_hasId = function(id) {
    return this.rowsAr[id];
}
dhtmlXGridObject.prototype.CF_copyRowContent = function(srcId, destId) {
    this.copyRowContent(srcId, destId);

    // copy the user data as well
    if (this.UserData[srcId]) {
        for (var i = 0; i < this.UserData[srcId].keys.length; i++) {
            this.setUserData(destId, this.UserData[srcId].keys[i], this.CF_getUserData(srcId, this.UserData[srcId].keys[i]));
        }
    }
}
dhtmlXGridObject.prototype.CF_genericSFLoadFunc = function(result, event) {
   if (event.status == true) {
     this.CF_dataSequence = [];
     this.CF_dataById = {};
     for (var i = 0; i < result.length; i++) {
         this.CF_dataSequence.push(result[i].Id);
         this.CF_dataById[result[i].Id] = result[i];
     }
     this.CF_displayData();
   } else {
     // an anomoly occurred - show the error to the user
     // TODO - do we need to disable things when an error occurs (like if grid doesn't load, hide toolbar)?
     alert(event.message);
   }
}
dhtmlXGridObject.prototype.CF_getRealGrid = function() {
    if (this._fake && this._realfake) return this._fake;
    return this;
}
// create our own because we don't want to call getRowById every time
dhtmlXGridObject.prototype.CF_getUserData = function(a, b) {
    var c = this.CF_getRealGrid().UserData[a];
    return c ? c.get(b) : "";
};
dhtmlXGridObject.prototype.CF_beginVFEdit = function(idd, ind) {
   if (this != this.CF_getRealGrid()) {
        return this.CF_getRealGrid().CF_beginVFEdit(idd, ind);
   }
   var sel = false;

	// in case the user doesn't have create access
   var sampleIdd = false;

   if (!idd) {
       // bulk editing - assuming we're here because something is already checked (calling function takes care of this)
       sel = this.CF_getGridCheckedRows();
       if (sel.length == 0) return;
       var rec = false;
       for (var i = 0; i < sel.length; i++) {
        rec = this.CF_getBufferSequenceRec(sel[i]);
       	if ($.isLiveId(rec.idd)) {
       		sampleIdd = rec.idd;
       		break;
       	}
       }
   } else if ($.isLiveId(idd)) {
   		sampleIdd = idd;
   }
   var dependencyList = this.CF_getFieldDependency(ind);
   var allId = dependencyList['allId'];
   var allFlds = dependencyList['allFlds'];
   if (!allId || !allId.length || allId.length == 0) return;

   // if we're showing record type, get the value
   // IF the selected id is nothing, then make sure ALL records have the same record type
   var has_rt = false;
   for (var i = 0; i < this.CF_fieldDef.length; i++) {
       if (this.CF_fieldDef[i]['field'] == 'RecordTypeId') {
           has_rt = true;
           break;
       }
   }
   var rt_val = false;
   if (has_rt) {
       if (!idd) {
           // make sure they all have the same record type
           var rec = false;
           for (var i = 0; i < sel.length; i++) {
              rec = this.CF_getBufferSequenceRec(sel[i]);
              if (this.CF_getUserData(rec.idd, 'deleted') || $.isGroupId(rec.idd)) continue;
              if (!rt_val) {
                  rt_val = this.CF_getUserData(rec.idd, 'RecordTypeId');
              } else {
                  if (this.CF_getUserData(rec.idd, 'RecordTypeId') != rt_val) {
                      alert('Please ensure that all checked records have the same record type.');
                      return;
                  }
              }
           }
       } else {
           rt_val = this.CF_getUserData(idd, 'RecordTypeId')
       }
   }
   if (rt_val == false || rt_val == null) rt_val = '';

   var vfUrl = CF_NAMESPACE_PREFIX + 'Configero_PropSelector?t=' + escape(this.CF_fieldDef[allId[0]]['object']) + (sampleIdd ? '&idd=' + escape(sampleIdd) : '') + '&rt=' + escape(rt_val) + '&f=' + escape(allFlds.join(','));
   vfUrl = $.CF_getApexURL(vfUrl);

   var g = this;
   var selectFunc = function(vals) {
       var recs = [];
       if (!idd) {
           for (var i = 0; i < sel.length; i++) {
               rec = g.CF_getBufferSequenceRec(sel[i]);
               if (g.CF_getUserData(rec.idd, 'deleted') || $.isGroupId(rec.idd)) continue;
               recs.push(rec);
           }
       } else {
           recs.push(g.CF_getByIdFromBackingData(idd));
       }
       for (var i = 0; i < vals.length; i++) {
           for (var j = 0; j < g.CF_fieldDef.length; j++) {
               if (g.CF_fieldDef[j].field == vals[i].field) {
                   // found the field
                   for (var k = 0; k < recs.length; k++) {
                     g.CF_setValueInCellRec(recs[k], j, vals[i].value);
                     g.CF_checkWasChanged(recs[k].idd, j, vals[i].value);
                   }
                   break; 
               }
           }
       }
       if (!idd) {
       		var idds = [];
       		for (var i = 0; i < recs.length; i++) {
               idds.push(recs[i].idd);
            }
       		g.callEvent('CF_bulkEditComplete', [allId, idds]);
       }
       $('#CF_vfDialog').dialog('close');
   };
   var vals = [];
   if (idd) {
       for (var i = 0; i < allId.length; i++) {
           vals.push({field: allFlds[i], value: this.CF_getRowValueInCell(idd, allId[i])});
       }
   }
   var initFunc = function() {
       return vals;
   };
   var ifr = $('<iframe style="width: 100%; height: 100%; border: 0px" />').attr('src', vfUrl);
   ifr.get(0).selectFunc = selectFunc;
   ifr.get(0).initFunc = initFunc;
   $('#CF_vfDialog').html(ifr).dialog('open');
}

dhtmlXGridObject.prototype.CF_updateLoadProgress = function(totRecs) {
    if (totRecs == undefined) totRecs = this.CF_dataSequence.length;
    $('#CF_progressCustomMessage').text('' + $.formatNumber(this.CF_numRecordsProcessed) + ' of ' + $.formatNumber(totRecs));
    $('#CF_progressBar').progressbar({value: 100 * (this.CF_numRecordsProcessed / totRecs)});
}
dhtmlXGridObject.prototype.CF_createBulkEditFooter = function() {
  var a = new Array();
  var hackField = '<input type="text" class="bulkAdd" readonly="readonly" style="border: 0px; background-color: transparent;" />';
  for (var i = 0; i < this.CF_fieldDef.length; i++) {
    var r = this.CF_fieldDef[i]['bulk_edit_override'];
    // hack for alignment
    if (r == '') a.push(hackField);
    else if (!this.CF_fieldDef[i]['updateable']) a.push(hackField);
    else if (r == undefined) {
        var typ = this.CF_fieldDef[i]['type'];
        //if (typ == 'ch') {
        //  a.push('<input class="bulkAdd" ind="' + i + '" value="1" type="checkbox">');
        //} else if (typ == 'edtxt' || typ == 'edn') {
        //  a.push('<input class="bulkAdd" ind="' + i + '" type="text">');
        if (typ == 'lkup' || typ == 'lkupnolink' || typ == 'lkupcombo') {
          a.push('<a href="javascript:void(0)" class="bulkAdd lookup" ind="' + i + '"><img src="/s.gif" class="lookupIcon" /></a>');
        } else if (typ == 'ch' || typ == 'edtxt' || typ == 'edn' || typ == 'vf' || typ == 'chvf' || typ == 'corotxt' || typ == 'plvf' || typ == 'edtxtvf') {
          a.push('<a href="javascript:void(0)" class="bulkAdd vf" ind="'+i+'"><img src="/s.gif" class="lookupIcon"></a>');
        } else if (typ == 'dhxCalendarA') {
          a.push('<input class="bulkAdd calendar" id="bulkAdd_' + i + '" readonly="readonly" ind="' + i + '" type="text">');
        } else if (typ == 'CF_dhxCalendarTime') {
          a.push('<input class="bulkAdd calendar_time" id="bulkAdd_' + i + '" readonly="readonly" ind="' + i + '" type="text">');
        } else {
          a.push(hackField);
        }
    } else {
        a.push(r);
    }
  }
  this.attachFooter(a.join(','));
}
dhtmlXGridObject.prototype.CF_getDateFormat = function() {
	return $.getDateFormat().replace('yyyy', '%Y').replace('MM', '%m').replace('dd', '%d');
}
dhtmlXGridObject.prototype.CF_activateBulkEditFields = function() {
  var bulkAddCalIds = [];
  var bulkAddCalTimeIds = [];

  var g = this;
  var obj = $(g.obj).closest('.gridbox');

  $('.bulkAdd', obj).each(function() {
      var t = $(this);
      var ind = t.attr('ind');
      if (t.hasClass('lookup')) {
          t.click(function() {
            var sel = g.CF_getGridCheckedRows();
            if (sel.length == 0) return;

            var t = $(this);
            var ind = t.attr('ind');

            g.CF_doLookup({index: ind}, function(params) {
				var idds = [];
                for (var i = 0; i < sel.length; i++) {
                	var rec = g.CF_getBufferSequenceRec(sel[i]);
                	if (g.CF_getUserData(rec.idd, 'deleted') || $.isGroupId(rec.idd)) continue;
                    g.CF_updateLookupValueInGridSeq(sel[i], ind, params['id'], params['text']);
                    idds.push(rec.idd);
                }
       			g.callEvent('CF_bulkEditComplete', [[ind], idds]);
                $('#CF_lookupDialog').dialog('close');
            });
          });
          return;
      }
      if (t.hasClass('vf')) {
          t.click(function() {
            g.CF_beginVFEdit(false, $(this).attr('ind'));
          });
          return;
      }
      t.change(function() {
          var t = $(this);
          var ind = t.attr('ind');
          var sel = g.CF_getGridCheckedRows();
          if (sel.length == 0) return;

          var row;
          var val = t.get(0).type == 'checkbox' ? (t.is(':checked') ? '1' : '0') : t.val();
          var idds = [];
          for (var i = 0; i < sel.length; i++) {
              rec = g.CF_getBufferSequenceRec(sel[i]);
              if (g.CF_getUserData(rec.idd, 'deleted') || $.isGroupId(rec.idd)) continue;
              idds.push(rec.idd);
                g.CF_setValueInCellRec(rec, ind, val);
                g.CF_checkWasChanged(rec.idd, ind, val);
          }
          g.callEvent('CF_bulkEditComplete', [[ind], idds]);
      });
      if (t.hasClass('calendar')) {
          bulkAddCalIds.push(t.attr('id'));
      } else if (t.hasClass('calendar_time')) {
      	bulkAddCalTimeIds.push(t.attr('id'));
      }
  });
  if (bulkAddCalIds.length > 0) {
      var bulkEditCalendar = new dhtmlXCalendarObject(bulkAddCalIds);
      g.callEvent("onDhxCalendarCreated", [bulkEditCalendar]);
      var bulkClearBtn = $('<input type="button" value="Select None" class="btn bulk_cal_select_none" />');
      $(bulkEditCalendar.base).append(
      	$('<div class="dhtmlxcalendar_selectnone_cont" />').append($('<ul class="dhtmlxcalendar_line" />').append($('<li style="width: 100%" class="dhtmlxcalendar_cell" />').append(bulkClearBtn)))
      );
      bulkClearBtn.click(function() {
          $(bulkEditCalendar.i[bulkEditCalendar.lastBulkEditInputId]).val('').change();
          bulkEditCalendar.hide();
      });

      // override show and inject our method
      bulkEditCalendar._show_old = bulkEditCalendar._show;
      bulkEditCalendar._show = function(inpId, autoHide) {
          this.lastBulkEditInputId = inpId;
          this._show_old(inpId, autoHide);
          var t = $(this.base);
          if (t.is(':visible')) {
            this.base.style.top = (t.position().top - 240) + 'px';
          }
      }
      bulkEditCalendar.setDateFormat(g.CF_getDateFormat());
      bulkEditCalendar.attachEvent('onClick', function() {
          // trigger change event on the field
          $(this.i[this.lastBulkEditInputId]).change();
          return true;
      });
  }
  if (bulkAddCalTimeIds.length > 0) {
      var bulkEditCalendarTime = new dhtmlXCalendarObject(bulkAddCalTimeIds);
      g.callEvent("onDhxCalendarCreated", [bulkEditCalendarTime, true]);
      var bulkClearBtn = $('<input type="button" value="Select None" class="btn bulk_cal_select_none" />');
      $(bulkEditCalendarTime.base).append(
      	$('<div class="dhtmlxcalendar_selectnone_cont" />').append($('<ul class="dhtmlxcalendar_line" />').append($('<li style="width: 100%" class="dhtmlxcalendar_cell" />').append(bulkClearBtn)))
      );
      bulkClearBtn.click(function() {
          $(bulkEditCalendarTime.i[bulkEditCalendarTime.lastBulkEditInputId]).val('').change();
          bulkEditCalendarTime.hide();
      });

      // override show and inject our method
      bulkEditCalendarTime._show_old = bulkEditCalendarTime._show;
      bulkEditCalendarTime._show = function(inpId, autoHide) {
          this.lastBulkEditInputId = inpId;
          this._show_old(inpId, autoHide);
          var t = $(this.base);
          if (t.is(':visible')) {
            this.base.style.top = (t.position().top - 240) + 'px';
          }
      }
      bulkEditCalendarTime.setDateFormat(g.CF_getDateFormat() + ' %h:%i %a');
      bulkEditCalendarTime.attachEvent('onClick', function() {
          // trigger change event on the field
          $(this.i[this.lastBulkEditInputId]).change();
          return true;
      });
  }
}
dhtmlXGridObject.prototype.CF_syncHeaders = function() {
    // override - in splits for some reason there are issues where hiding and showing the same row keeps scrolling down more and more
    // so for now just assume a height of 58 for the 2nd node since that's all we care about
    /*if (!(this.noHeader || this._fake.hdr.scrollHeight == this.hdr.offsetHeight)) {
        if (this.hdr.rows.length < 3) return;
        var a = this._fake.hdr.rows[2].childNodes.length;
        this._fake.hdr.rows[2].childNodes[0].style.height = this.hdr.rows[2].childNodes[a].style.height = 'auto';
    }*/
}
dhtmlXGridObject.prototype.CF_refreshSortIcons = function() {
	// hide the old sort img and clear out current icons
	this.sortImg.style.visibility = 'hidden';
	$('.sortImg', $(this.hdrBox)).remove();
	if (this._fake) {
		this._fake.sortImg.style.visibility = 'hidden';
		$('.sortImg', $(this._fake.hdrBox)).remove();
	}

	if (!this.CF_sortSequence) return;
	for (var x = 0; x < this.CF_sortSequence.length; x++) {
		// if this is in the "fake", display it there
		var g = false;
		if (this.CF_splitAt && this.CF_sortSequence[x]._index <= this.CF_splitAt) {
			g = this._fake;
		} else {
			g = this;
		}
		var d = g.hdr.rows[1].cells[this.CF_sortSequence[x]._index];
        var i = g.getPosition(d, g.hdrBox), j = d.offsetWidth;

		// create a new image
		var img = document.createElement("IMG");
		img.className = 'sortImg';
		img._index = this.CF_sortSequence[x]._index;
		img.src = this.imgURL + "sort_" + (this.CF_sortSequence[x]._sort == "asc" ? "asc" : "desc") + ".gif";
		img.style.position = 'absolute';
    	g.hdrBox.appendChild(img);
    	img.style.left = Number(i[0] + j - 13) + "px";
        img.style.top = Number(i[1] + 5) + "px";
        img.onclick = (function() {
        	return function() {
    			g._onHeaderClick.apply({grid: g}, [null, d]);
			};
		})();
	}
}
dhtmlXGridObject.prototype.CF_forceSort = function(forceSequence) {
	if (forceSequence === false) return;
	this.CF_gridSortRows(0, 0, 0, false, forceSequence);
}
dhtmlXGridObject.prototype.CF_gridSortRows = function(a, b, c, skipShift, forceSequence) {
    a = a || 0;
    b = b || this.fldSort[a];
    c = (c || "asc").toLocaleLowerCase();

	if (!this.CF_sortSequence) this.CF_sortSequence = [];
	var forceSort = skipShift ? c : 'asc';
	if (this.CF_sortSequence.length == 1 && this.CF_sortSequence[0]._index == a) {
		if (this.CF_sortSequence[0]._sort == 'asc') forceSort = 'des';
	}
	if (!skipShift) {
		if (!CF_currentKeysPressed[16]) {
			// shift not pressed
			this.CF_sortSequence = [];
		}
	} else {
		this.CF_sortSequence = [];
	}
	// go through the sort sequence and if the same
	var foundIt = false;
	for (var i = 0; i < this.CF_sortSequence.length; i++) {
		if (this.CF_sortSequence[i]._index == a) {
			if (this.CF_sortSequence[i]._sort == 'asc') {
				this.CF_sortSequence[i]._sort = 'des';
			} else {
				this.CF_sortSequence[i]._sort = 'asc';
			}
			foundIt = true;
			break;
		}
	}
	if (!foundIt) {
		var e = this.cellType[a], f = "getValue";
        e == "link" && (f = "getContent");
		this.CF_sortSequence.push({_sort: forceSort, _index: a, _func: f, _type: b, _field: this.CF_fieldDef[a].field});
	}
	if (forceSequence) {
		this.CF_sortSequence = [];
		if (forceSequence.length == undefined) forceSequence = [forceSequence];
		for (var i = 0; i < forceSequence.length; i++) {
			if (forceSequence[i]._field) {
				forceSequence[i]._index = this.CF_getFieldIndex(forceSequence[i]._field);
				if (!forceSequence[i]._index) continue;
			}
			if (forceSequence[i]._index == undefined) forceSequence[i] = {_index: forceSequence[i]};
			var e = this.cellType[forceSequence[i]._index], f = "getValue";
			e == "link" && (f = "getContent");
			if (!forceSequence[i]._sort) forceSequence[i]._sort = 'asc';
			forceSequence[i]._func = f;
			forceSequence[i]._type = this.fldSort[forceSequence[i]._index];
			this.CF_sortSequence.push(forceSequence[i]);
		}
	}

    if (this.isTreeGrid()) {
		this.CF_sortTreeRows(0);
	    this._renderSort(0, !0);
	    this.callEvent("onGridReconstructed", [])
    } else {
        var d = {};
        for (var g = 0; g < this.rowsBuffer.length; g++) {
            d[this.rowsBuffer[g].idd] = [];
            for (var x = 0; x < this.CF_sortSequence.length; x++) {
            	d[this.rowsBuffer[g].idd].push(this._get_cell_value(this.rowsBuffer[g], this.CF_sortSequence[x]._index, this.CF_sortSequence[x]._func));
           	}
        }
        this._sortRows(a, b, c, d);
    }
    this.callEvent("onAfterSorting", [a, b, c])
}
dhtmlXGridObject.prototype.CF_sortTreeRows = function(a) {
    var d = {};
    var c = this._h2.get[a].childs;
    for (var i = 0; i < c.length; i++) {
    	var e = c[i];

		d[e.id] = [];
		for (var x = 0; x < this.CF_sortSequence.length; x++) {
			d[e.id].push(this._get_cell_value(e.buff, this.CF_sortSequence[x]._index, this.CF_sortSequence[x]._func));
	    }
    }
	this.CF_gridSortCore(false, false, false, d, c);
	for (var d = 0; d < c.length; d++) {
		c[d].childs.length && this.CF_sortTreeRows(c[d].id), c[d].index = d;
	}
}
dhtmlXGridObject.prototype.CF_gridSortCore = function(a, b, c, d, e) {
   var h = "sort";
   if (this._sst)
       e.stablesort = this.rowsCol.stablesort, h = "stablesort";

   var covs = {};
   for (var i = 0; i < this.CF_sortSequence.length; i++) {
   	if (this.CF_sortSequence[i]._type == 'pl') {
       var co = this.getCombo(this.CF_sortSequence[i]._index);
       var cov = {};
       for (var j = 0; j < co.keys.length; j++) {
           cov[co.keys[j]] = co.values[j].toLocaleLowerCase();
       }
       covs[this.CF_sortSequence[i]._index] = cov;
   	}
   }
   // go through all sort sequence - if pl, set up "co" and "cov"
   var g = this;
   var ss = this.CF_sortSequence;
   e[h](function(aa, bb) {
	   for (var i = 0; i < ss.length; i++) {
	   		a = ss[i]._index;
			b = ss[i]._type;
			b.length > 4 && (b = window[b]);
			c = ss[i]._sort;

			var r = 0;
			if (b == 'cus') {
				r = g._customSorts[a](d[aa.idd || aa.id][i], d[bb.idd || bb.id][i], c, aa.idd || aa.id, bb.idd || bb.id);
			} else if (typeof b == 'function') {
				r = b(d[aa.idd || aa.id][i], d[bb.idd || bb.id][i], c, aa.idd || aa.id, bb.idd || bb.id);
			} else if (b == 'pl') {
		       var cov = covs[a];
		       var tx = cov[d[aa.idd || aa.id][i]] || '';
		       var ty = cov[d[bb.idd || bb.id][i]] || '';
		       r = tx == ty ? 0 : c == 'asc' ? (tx > ty ? 1 : -1) : (tx > ty ? -1 : 1);
       		} else if (b == "str") {
		       // fix for dhtmlxgrid - return 0 when str sort is called - and to a case insensitive comparison
		       r = d[aa.idd || aa.id][i].toLocaleLowerCase() == d[bb.idd || bb.id][i].toLocaleLowerCase() ? 0 :
           			(c == "asc" ? d[aa.idd || aa.id][i].toLocaleLowerCase() > d[bb.idd || bb.id][i].toLocaleLowerCase() ? 1 : -1 : d[aa.idd || aa.id][i].toLocaleLowerCase() < d[bb.idd || bb.id][i].toLocaleLowerCase() ? 1 : -1);
   			} else if (b == "int") {
           		var e = parseFloat(d[aa.idd || aa.id][i]), e = isNaN(e) ? -99999999999999 : e, j = parseFloat(d[bb.idd || bb.id][i]), j = isNaN(j) ? -99999999999999 : j;
           		r = c == "asc" ? e - j : j - e;
           	} else if (b == "date") {
           		var e = $.parseDateTime(d[aa.idd || aa.id][i]) || Date.parse("01/01/1900"), j = $.parseDateTime(d[bb.idd || bb.id][i]) || Date.parse("01/01/1900");
           		r = c == "asc" ? e - j : j - e
           	}
       		if (r != 0) return r;
	   }
	   return 0;
   });
}
dhtmlXGridObject.prototype.CF_collapseFieldDefArr = function(ind, def) {
  var a = new Array();
  for (var i = 0; i < this.CF_fieldDef.length; i++) {
    var x = this.CF_fieldDef[i][ind] || def || '';
    if (typeof x == 'string') x = x.replace(/,/g,'');
    a.push(x);
  }
  return a;
}
dhtmlXGridObject.prototype.CF_collapseFieldDef = function(ind, def) {
  return this.CF_collapseFieldDefArr(ind, def).join(',');
}

dhtmlXGridObject.prototype.CF_checkCellFunc = function(rid, cindex, state) {
    this.CF_checkWasChanged(rid, cindex, state);
    return true;
}

dhtmlXGridObject.prototype.CF_getDynamicBeginFieldIndex = function() {
    for (var i = 0; i < this.CF_fieldDef.length; i++) {
        if (this.CF_fieldDef[i].dynamicFieldIndex == 0) {
            return i;
        }
    }
    return this.CF_fieldDef.length;
}
dhtmlXGridObject.prototype.CF_getFieldIndex = function(apiName) {
    for (var j = 0; j < this.CF_fieldDef.length; j++) {
        if (this.CF_fieldDef[j].field == apiName) return j;
    }
}
dhtmlXGridObject.prototype.CF_getFieldDependency = function(ind) {
   // get this index - if it's dependent on something else, go up the chain
   var iid = ind;
   while (iid && this.CF_fieldDef[iid].controller) {
       iid = this.CF_indexByField[this.CF_fieldDef[iid].controller];
   }
   if (!iid) {
    	alert('A dependent field is currently displayed in the grid without the parent column.  Please use the hide/show column screen to select the parent column for display in the grid.');
  		return {};
   }
   var allId = [];
   var allFlds = [];
   if (this.CF_fieldDef[iid]['field']) {
	   allId.push(iid);
	   allFlds.push(this.CF_fieldDef[iid]['field']);
	   for (var i = 0; i < allFlds.length; i++) {
	     for (var j = 0; j < this.CF_fieldDef.length; j++) {
	         if (allFlds[i] == this.CF_fieldDef[j].controller) {
	             allId.push(j);
	             allFlds.push(this.CF_fieldDef[j]['field']);
	         }
	     }
	   }
   }
   return {'allId': allId, 'allFlds': allFlds};
}
dhtmlXGridObject.prototype.CF_isGroupedField = function(ind) {
	var deps = this.CF_getFieldDependency(ind);
	deps = deps['allId'];
	var aa =  {};
	for (var j = 0; j < this.CF_groupFields.length; j++) {
		aa[this.CF_groupFields[j]] = 1;
	}
	for (var i = 0; i < deps.length; i++) {
		if (aa[deps[i]]) {
			return true;
		}
	}
}
// stage = 0 (before start), 1 (editor opened), 2 (editor closed) - new value and old value in editor closed
dhtmlXGridObject.prototype.CF_editCellFunc = function(stage, rid, cindex, new_value, old_value) {
    if (cindex == this.CF_indexByField['__selectall']) return true;
    if (this.CF_getUserData(rid, 'deleted')) return false;
    if ($.isGroupId(rid)) {
    	return false;
    } else if ($.isTemporaryId(rid)) {
        // new - make sure it's createable
        if (!this.CF_fieldDef[cindex]['createable']) return false;
    } else {
        // already exists...make sure it's updateable
        if (!this.CF_fieldDef[cindex]['updateable']) return false;
    }
    if (stage == 0) {
    	// only do this if not a drop down lookup
        if (this.CF_fieldDef[cindex]['type'] != 'lkupcombo' && this.CF_fieldDef[cindex]['related']) {
            var lkupRid = rid;
            var g = this;
            this.CF_doLookup({index: cindex}, function(params) {
                g.CF_updateLookupValueInGrid(lkupRid, cindex, params['id'], params['text']);
                if (g.CF_isInGroupMode() && g.CF_isGroupedField(cindex)) {
                	g.CF_reevaluateGroupRows([lkupRid]);
                }
                $('#CF_lookupDialog').dialog('close');
            });
            return false;
        }
    } else if (stage == 2) {
        // TODO - any validations?
        if (this.CF_fieldDef[cindex]['type'] == 'lkupcombo') {
        	this.CF_checkWasChanged(rid, cindex, this.CF_getUserData(rid, this.CF_fieldDef[cindex].field));
            if (this.CF_isInGroupMode() && this.CF_isGroupedField(cindex)) {
            	this.CF_reevaluateGroupRows([rid]);
            }
        } else if (new_value !== old_value) {
            // value not same as it was before the edit - check and see if it's different than the orig
            this.CF_checkWasChanged(rid, cindex, new_value);
            this.CF_setValueInTreeCacheHack(rid, cindex, new_value);
            if (this.CF_isInGroupMode() && this.CF_isGroupedField(cindex)) {
            	this.CF_reevaluateGroupRows([rid]);
            }
        }
    }
    return true;
}
dhtmlXGridObject.prototype.CF_serializeToCSV = function(delim) {
	// Dutch and German CSV is semicolon delimited 
	if (!delim) delim = UserContext && UserContext.locale && (UserContext.locale.beginsWith('de') || UserContext.locale.beginsWith('nl')) ? ';' : ',';

    var sel = this.CF_getCheckedRowsVisible();
    if (sel.length == 0) {
    	sel = this.CF_getRowsVisible();
    	if (sel.length == 0) {
    		alert('No records selected.');
    		return;
    	}
    }

    // get the columns that have a width > 0 and have a title
    var num = this.CF_fieldDef.length;
    var txt;
    var inds = [];
    var recs = [];
    var rec = [];
    for (var i = 0; i < num; i++) {
        if (this.getColWidth(i) == 0 || this.CF_fieldDef[i]['skip_export']) continue;
        rec.push($.escapeCSV(this.CF_fieldDef[i]['export_label'] || this.CF_fieldDef[i]['name'], delim));
        inds.push(i);
    }
    recs.push(rec.join(delim));

	var tmpVal = false;
	var decimalSeparator = $.localeDecimalSeparator();
    for (var i = 0; i < sel.length; i++) {
        rec = [];
        var trec = this.CF_getBufferSequenceRec(sel[i]);
        for (var j = 0; j < inds.length; j++) {
        	tmpVal = this.CF_getValueFromCellRec(trec, inds[j]);
        	if (tmpVal && this.CF_fieldDef[inds[j]]['numberFormat']) {
        		// go ahead and replace the '.' with the decimalSeparator
        		tmpVal = '' + tmpVal;
        		tmpVal = tmpVal.replace('.', decimalSeparator);
	        }

            rec.push($.escapeCSV(tmpVal, delim));
        }
        recs.push(rec.join(delim));
    }
    // works fine in chrome, but not with chrome frame
    //window.open('data:text/csv,' + escape(recs.join('\n')), '_blank');
    recs = recs.join('\n');
    return recs;
}
dhtmlXGridObject.prototype.CF_exportToCSV = function(delim, name, type) {
	if (!name) name = 'export.csv';
	if (!type) type = 'text/csv';
	$.downloadFile(this.CF_serializeToCSV(delim), name, type);
}
// can only happen on visible rows, so continue to use the cells method
dhtmlXGridObject.prototype.CF_updateLookupValueInGrid = function(rid, cIndex, id, text) {
    // the data was changed is basically the ID waschanged
    this.setUserData(rid, this.CF_fieldDef[cIndex]['field'], id);
    this.CF_setValueInCellRec(this.CF_getByIdFromBackingData(rid), cIndex, text);
    this.CF_checkWasChanged(rid, cIndex, id);
}
dhtmlXGridObject.prototype.CF_reevaluateGroupRows = function(ids) {
	if (!ids || ids.length == 0 || !this.CF_isInGroupMode()) return;
	var selId = this.getSelectedId();

	var prevFilters = this.CF_getFilters();	
	this.CF_clearFilters();

	for (var i = 0; i < ids.length; i++) {
			var rec_grp_id = '_grp';
			var checkedRows = {};
			var prev_rec_grp_id = false;
			var grp_vals = [];

    		var rec = this.CF_getByIdFromBackingData(ids[i]);

			for (var j = 0; j < this.CF_groupFields.length; j++) {
				rec_grp_id += '_';
				var ind = this.CF_groupFields[j];
				var data = this.CF_getValueFromCellRec(rec, ind);
            	if (this.CF_fieldDef[ind]['related']) {
            		rec_grp_id += this.CF_getUserData(ids[i], this.CF_fieldDef[ind]['field']);
                } else {
                	rec_grp_id += data;
                }
                grp_vals.push(data);
                if (!checkedRows[rec_grp_id]) {
                	checkedRows[rec_grp_id] = this.CF_hasId(rec_grp_id);
                }
                if (!checkedRows[rec_grp_id]) {
                	// create this one
                	var d = [];
                	for (var k = 0; k <= ind; k++) {
                		d.push('');
                	}
                	for (var k = 0; k <= j; k++) {
                		d[this.CF_groupFields[k]] = grp_vals[k];
                	}
                	this.CF_addRow(rec_grp_id, d, prev_rec_grp_id)
                	checkedRows[rec_grp_id] = true;
                }
                prev_rec_grp_id = rec_grp_id;
			}
			if (this.getParentId(ids[i]) != rec_grp_id) {
				/*if (!this.CF_isRowRendered(ids[i])) {
					this.showRow(ids[i]);
				}*/
				this.moveRowTo(ids[i], rec_grp_id, "move", "child", this);
			}
	}
	this.CF_purgeEmptyGroups();
	this.CF_applyFilters(prevFilters);
	if (selId && this.getSelectedId() != selId) {
	    this.CF_showRow(selId);
		this.selectRowById(selId)
	}
}
dhtmlXGridObject.prototype.CF_showRow = function(sel) {
	try {
		this.showRow(sel);
		return true;
	} catch(e) {
		// happens if in treegrid and sel is not in current view (ie - filtered out)
	}
}
dhtmlXGridObject.prototype.CF_purgeEmptyGroups = function() {
	if (!this.CF_isInGroupMode()) return;
       	// check for any blank groups (no leafs) and delete
       	var parentsToCheck = {};
       	var pid = false;
       	var toDel = [];
        this._h2.forEachChild(0, function(r) {
        	if (!$.isGroupId(r.id)) return;
        	if (this.hasChildren(r.id)) return;
        	pid = this.getParentId(r.id);
        	if (pid != null && pid != '') parentsToCheck[pid] = 1;
        	toDel.push(r.id);
        }, this);
        if (toDel.length > 0) {
        	// scroll to top and do this
		    if (this.getRowsNum() > 0) {
		        this.CF_showRow(this.CF_getBufferSequenceRec(0).idd);
		    }

	        for (var i = 0; i < toDel.length; i++) {
	        	this.CF_deleteRow(toDel[i]);
	        }
	    }
        while (true) {
        	if ($.isEmptyObject(parentsToCheck)) break;
        	var tmpParents = parentsToCheck;
        	parentsToCheck = {};
        	for (var id in tmpParents) {
	        	if (this.hasChildren(id)) continue;
	        	pid = this.getParentId(id);
	        	if (pid != null && pid != '') parentsToCheck[pid] = 1;
	        	this.CF_deleteRow(id);
        	}
        }
}
dhtmlXGridObject.prototype.CF_flushIdsToDel = function() {
    if (!$.isEmptyObject(this.CF_idsToDel)) {
        for (var i = this.CF_dataSequence.length - 1; i >= 0; i--) {
            if (this.CF_idsToDel[this.CF_dataSequence[i]]) {
                this.CF_dataSequence.splice(i, 1);
            }
        }
        this.CF_idsToDel = {};
        this.CF_purgeEmptyGroups();
    }
}
dhtmlXGridObject.prototype.CF_startFastOperations = function() {
	this.startFastOperations();
}
dhtmlXGridObject.prototype.CF_stopFastOperations = function() {
	this.stopFastOperations();

  	if (this._srnd) this._update_srnd_view();
  	if (this._fake) this._fake._fixAlterCss();
  	this._fixAlterCss();
}
dhtmlXGridObject.prototype.CF_deleteRows = function() {
    var sel = this.CF_getGridCheckedRows();
    if (sel.length == 0) return;
    if (confirm('Are you sure you want to delete the checked records?')) {
        this.CF_idsToDel = {};
        for (var i = sel.length - 1; i >= 0; i--) {
            rec = this.CF_getBufferSequenceRec(sel[i]);

            if (this.CF_getUserData(rec.idd, 'deleted')) continue; // already deleted
            if ($.isGroupId(rec.idd)) continue;

            if ($.isTemporaryId(rec.idd)) {
                this.CF_deleteRow(rec.idd);

                // remove from dataSequence
                this.CF_idsToDel[rec.idd] = 1;
            } else {
                // flag it as deleted but don't do it yet
                this.setUserData(rec.idd, 'deleted', true);
                if (this.CF_isRowRendered(rec.idd)) {
                    this.setRowTextStyle(rec.idd,"text-decoration : line-through;");
                }
            }
        }
        this.CF_flushIdsToDel();
    }
}
// assumes unfiltered since dhtmlx has bugs when adding rows in filtered mode
dhtmlXGridObject.prototype.CF_addRow = function(idd, rec, parentId) {
    if (this._f_rowsBuffer) {
    	if (this.isTreeGrid()) {
    		alert('An error occurred.  Tree add rows while filtered is not supported.');
    		return;
    	}
    }

    // force a scroll to the top since if split, adds mess things up
    var firstRowId = false;
    if (this.getRowsNum() > 0) {
    	firstRowId = this.CF_getBufferSequenceRec(0).idd;
        this.CF_showRow(firstRowId);
    }

	// if filtered, add to the filter as well
	if (this.isTreeGrid() && !parentId && firstRowId) {
		// add before first row
		this.addRowBefore(idd, rec, firstRowId);
	} else {
    	this.addRow(idd, rec, 0, parentId);
    }
    if (this._f_rowsBuffer) {
    	if (this.isTreeGrid()) {
    		// TODO - revisit
    		/*
    		var x = this._h2.get[idd];
    		var y = new dhtmlxHierarchy();
    		y.buff = x.buff;
    		this._f_rowsBuffer.add(y, parentId);
    		*/
    	} else {
	    	var x = this.CF_getByIdFromBackingData(idd);
    		this._f_rowsBuffer.unshift(x);
    	}
    }
}

dhtmlXGridObject.prototype.CF_deleteRow = function(idd) {
	// assumes not filtered IF tree - if filtered, then there's a lot more to it since srnd is also involved
	if (this.isTreeGrid() && this.rowsAr[idd] && this.getRowIndex(idd) < 0) {
		// not yet visible so can't delete it - make it visible and then delete
		this.CF_showRow(idd);
	}
	var ret = this.deleteRow(idd);
	if (ret && !this.isTreeGrid() && this._f_rowsBuffer) {
		// remove it from the filtered table as well
		for (var i = 0; i < this._f_rowsBuffer.length; i++) {
			if (this._f_rowsBuffer[i].idd == idd) {
				this._f_rowsBuffer.splice(i, 1);
				break;
			}
		}
	}
	return ret;
}
// fix bug where it spliced _fake differently than the rowsCol and rowsBuffer variables
// fix a bug in treegrid where removing a node doesn't remove it from the _f_rowsBuffer list
dhtmlXGridObject.prototype._removeTrGrRow = function(a, b) {
    if (b)
        this._h2.forEachChild(b.id, function(a) {
            this._removeTrGrRow(null, a);
            delete this.rowsAr[a.id]
        }, this);
    else {
        var c = this.getRowIndex(a.idd), b = this._h2.get[a.idd];
        if (c != -1 && c !== this.undefined) {
            var d = 1;
            b && b.state == "minus" && (d += this._getOpenLenght(b.id, 0));
            for (var e = 0; e < d; e++)
                this.rowsCol[e + c] && this.rowsCol[e + c].parentNode.removeChild(this.rowsCol[e + c]);
            if (this._fake) {
                for (e = 0; e < d; e++)
                    this._fake.rowsCol[e + c] && this._fake.rowsCol[e + c].parentNode.removeChild(this._fake.rowsCol[e + c]);
                this._fake.rowsCol.splice(c, d);
            }
            this.rowsCol.splice(c, d);
            this.rowsBuffer.splice(c, d)
        }
        b && (this._removeTrGrRow(null, b), delete this.rowsAr[b.id], b.parent.childs.length == 1 && (this._h2.change(b.parent.id, "state", dhtmlXGridObject._emptyLineImg), this._updateTGRState(b.parent)), this._h2.remove(b.id), this._f_rowsBuffer && this._f_rowsBuffer.remove(b.id))
    }
};

dhtmlXGridObject.prototype.CF_addBlankRow = function() {
    var idd = '-' + (new Date()).getTime();
    var newRec = [];
    for (var i = 0; i < this.CF_fieldDef.length; i++) {
        if (this.CF_fieldDef[i]['type'] == 'ch' || this.CF_fieldDef[i]['type'] == 'chro') {
            newRec.push('0');
        } else if (this.CF_fieldDef[i]['defaultvalue']){
            newRec.push(this.CF_fieldDef[i]['defaultvalue']);
        } else{
            newRec.push('');
        }
    }

    // clear the filters first
    this.CF_clearFilters();

    this.CF_addRow(idd, newRec);
    this.CF_dataSequence.unshift(idd);

    this.CF_reevaluateGroupRows([idd]);
    return idd;
}

dhtmlXGridObject.prototype.CF_resetGrid = function() {
 this.clearAll();
 this.CF_clearFilters();

 // bug in treegrid - this gets set to an array with a null and breaks the render
 this._fillers = undefined;
 this._f_rowsBuffer = undefined;

 this.CF_idsToDel = {};
 this.CF_dataById = false; // keep track of what SF account ID goes in what sequence
 this.CF_relatedById = {};
 this.CF_errors = [];
 this.CF_dataSequence = [];     // sequenced based on what was loaded
 this.CF_lastIndex = 0;
 this.CF_numRecordsProcessed = 0;
 this.CF_loadComplete = false;
 this.callEvent('CF_resetGridComplete',[]);
}
dhtmlXGridObject.prototype.CF_clearFilters = function() {
	if (!this.filters) return;
    var obj = $(this.obj).closest('.gridbox');
    var hasFilter = false;
    $('.hdrcell :input', obj).each(function() {
        hasFilter = true;
        var t = $(this);
        if (t.hasClass('master_checkbox') || t.hasClass('bulkAdd')) return;
        if (this.type == 'checkbox') this.checked = false;
        else {
           t.val('').removeAttr('filter_prop');
        }
    });
    // run the method to recompute filters
    if (hasFilter) {
    	this.filterByAll();
    	this._f_rowsBuffer = undefined;
    	this.callEvent('CF_onFiltersUpdated',[]);
    }
}
dhtmlXGridObject.prototype.CF_getFilters = function() {
    var obj = $(this.obj).closest('.gridbox');
    var filters = {};
    var that = this;
    $('.hdrcell :input', obj).each(function() {
        var t = $(this);
        if (t.hasClass('master_checkbox') || t.hasClass('filter_prop') || t.hasClass('bulkAdd')) return;
        var ind = t.closest('td').index();
        var fld = false;
        if (that.CF_fieldDef) fld = that.CF_fieldDef[ind]['field'];
        // no need to keep track of the __error one either since the user can't really see it ever - it's programmatically handled
        if (!fld || fld == '__error') return;
        var r = {};

        if (this.type == 'checkbox') {
            if (!this.checked) return;
            r['checked'] = this.checked;
        } else {
            r['value'] = t.val();
            r['filter_prop'] = t.attr('filter_prop');
            if (r['value'] == '' && !r['filter_prop']) return;
        }
        filters[fld] = r;
    });
    return filters;
}
// because the plus/minus don't work reflect reality sometimes in treegrid
dhtmlXGridObject.prototype.CF_filterEnd = function(filters) {
	// re-apply the sort
	this.CF_forceSort(this.CF_sortSequence);

	if (!this.isTreeGrid()) return;
	var gind = this.CF_indexByField['__group'];
	var plusImg = this.imgURL + "plus.gif";
   	for (var idd in this.rowsAr) {
   		if (!this.CF_isRowRendered(idd)) continue;
   		var c = this._h2.get[idd];
   		if (!c) c = this._f_rowsBuffer.get[idd];
   		if (c.childs.length && c.state == 'plus') {
        	// make sure the minus sign isn't displaying
        	if (this.rowsAr[idd].imgTag.src.indexOf(plusImg) < 0) {
        		this.rowsAr[idd].imgTag.src = plusImg;
        	}
        }
    }
}
// assumes filters are blank to start off with
dhtmlXGridObject.prototype.CF_applyFilters = function(filters) {
    if (!filters || !this.filters || $.isEmptyObject(filters)) return;
    var obj = $(this.obj).closest('.gridbox');
    var hasFilter = false;
    var that = this;
    $('.hdrcell :input', obj).each(function() {
        hasFilter = true;
        var t = $(this);
        if (t.hasClass('master_checkbox') || t.hasClass('filter_prop') || t.hasClass('bulkAdd')) return;
        var ind = t.closest('td').index();
        var fld = that.CF_fieldDef[ind]['field'];
        if (!fld) return;
        if (!filters[fld]) return;

        if (this.type == 'checkbox') {
            if (filters['fld']['checked']) this.checked = true;
        } else {
            t.val(filters[fld]['value']);
            if (filters[fld]['filter_prop']) {
                // set the attribute and find the parent and then the class filter_prop in the parent and set the value there as well
                t.attr('filter_prop', filters[fld]['filter_prop']);
                t.parent().find('.filter_prop').val(filters[fld]['filter_prop']);
            }
        }
    });
    // run the method to recompute filters
    if (hasFilter) {
    	this.filterByAll();
    	var sel = this.getSelectedId();
    	if (sel) this.CF_showRow(sel);
    	this.callEvent('CF_onFiltersUpdated',[]);
    }
}
dhtmlXGridObject.prototype.CF_getFakeCell = function(cindex, rid) {
    var fakeCellObj = false;
    if (cindex <= this.CF_splitAt) {
        fakeCellObj = this.rowsAr[rid] && this.rowsAr[rid].cells ? this.rowsAr[rid].cells[cindex] : false;
    }
    return fakeCellObj;
}
dhtmlXGridObject.prototype.CF_setCellWasChanged = function(cellObj, rid, cindex, wasChanged) { 
    var fakeCellObj = this.CF_getFakeCell(cindex, rid);
    cellObj.cell.wasChanged = wasChanged;
    if (fakeCellObj) fakeCellObj.wasChanged = wasChanged;
}
dhtmlXGridObject.prototype.CF_addClassToCell = function(cellObj, rid, cindex, cls) {
    var fakeCellObj = this.CF_getFakeCell(cindex, rid);
    $(cellObj.cell).addClass(cls);
    if (fakeCellObj) $(fakeCellObj).addClass(cls);
} 
dhtmlXGridObject.prototype.CF_removeClassFromCell = function(cellObj, rid, cindex, cls) {
    var fakeCellObj = this.CF_getFakeCell(cindex, rid);
    $(cellObj.cell).removeClass(cls);
    if (fakeCellObj) $(fakeCellObj).removeClass(cls);
} 
dhtmlXGridObject.prototype.CF_checkWasChanged = function(rid, cindex, text) {
    if (this.CF_fieldDef[cindex]['skip_track_changes']) {
        return this.CF_setWasChanged(rid, cindex, false);
    } else {
        var prevVal = '';
        if (!$.isTemporaryId(rid)) {
            if (this.CF_fieldDef[cindex]['related']) {
                // related - means we need to check the ID of this as opposed to the text
                prevVal = this.CF_relatedById[rid][this.CF_fieldDef[cindex]['field']];
            } else {
                prevVal = this.CF_dataById[rid][cindex];
            }
        }

        // to make it easier to compare '0' with 0
        if ((typeof text) == 'number') {
        	prevVal = parseFloat(prevVal);
        } else if ((typeof prevVal) == 'number') {
        	text = parseFloat(text);
        }
        return this.CF_setWasChanged(rid, cindex, prevVal != text);
    }
}
dhtmlXGridObject.prototype.CF_setWasChanged = function(rid, cindex, wasChanged, hasError, skipDirtyFlag) {
    if (this.CF_isRowRendered(rid)) {
        if (hasError == undefined) hasError = false;
        var cellObj = this.cells(rid, cindex);
        this.CF_setCellWasChanged(cellObj, rid, cindex, wasChanged);
        if (!wasChanged) {
            this.CF_removeClassFromCell(cellObj, rid, cindex, 'changed_flag errored_flag');
        } else {
            this.CF_addClassToCell(cellObj, rid, cindex, 'changed_flag' + (hasError ? ' errored_flag' : '')); 
        }
    }

    if (wasChanged && !skipDirtyFlag) this.setUserData(rid, 'CF_dirty', true);
    // else we will re-check on a new render anyway
    return wasChanged;
}

// could be for records not yet visible
dhtmlXGridObject.prototype.CF_updateLookupValueInGridSeq = function(bufferSeq, cIndex, id, text) {
    // the data was changed - check the rows buffer
    rec = this.CF_getBufferSequenceRec(bufferSeq);
    if (this.CF_getUserData(rec.idd, 'deleted') || $.isGroupId(rec.idd)) return;
    this.setUserData(rec.idd, this.CF_fieldDef[cIndex]['field'], id);
    this.CF_setValueInCellRec(rec, cIndex, text);
    this.CF_checkWasChanged(rec.idd, cIndex, id);
}


// don't want this anymore
dhtmlXGridObject.prototype._loadSelectOptins = function(a, b) { };

// override so we can remove ALL checked boxes on an uncheck
dhtmlXGridObject.prototype._in_header_master_checkbox = function(a, b, c) {
    a.innerHTML = c[0] + "<input type='checkbox' />" + c[1];
    var d = this;
    a.getElementsByTagName("input")[0].onclick = function(a) {
        d._build_m_order();
        var c = d._m_order ? d._m_order[b] : b, g = this.checked ? 1 : 0;
        var ff = this.checked ? d.forEachRowA : d.forEachRow;
        ff(function(a) {
            var b = this.cells(a, c);
            if (b.isCheckbox())
                b.setValue(g), b.cell.wasChanged = !0;
            this.callEvent("onEditCell", [1, a, c, g]);
            this.callEvent("onCheckbox", [a, c, g])
        });
        (a || event).cancelBubble = !0
    }
};

// override so we can do parsefloat based on locale
dhtmlXGridObject.prototype._in_header_numeric_filter = function(a, b) {
    this._in_header_text_filter.call(this, a, b);
    var thousandsSeparator = $.localeThousandsSeparator();
    var decimalSeparator = $.localeDecimalSeparator();

    var pf = function(num) {
    	// convert to regular "." decimal with no thousands separator
    	return parseFloat(num.replace(thousandsSeparator, '').replace(decimalSeparator, '.'));
    }
    a.firstChild._filter = function() {
        var a = this.value
        if (a) {
        	var b, e = "==", g = null;

        	// if only equal sign, match on empty strings in numeric column
        	var f = (a == '=' ? "''" : pf(a.replace("=", "")));
        	var ext = f == "''" ? '' : " && v !== ''";
            if (a.indexOf("..") != -1)
                return a = a.split(".."), f = pf(a[0]), g = pf(a[1]), function(a) {
                    return a >= f && a <= g ? !0 : !1
                };
            if (b = a.match(/>=|<=|>|</))
                e = b[0], f = pf(a.replace(e, ""));
            return Function("v", "return v " + e + " " + f + " " + ext + ";")
        }
        return ""
    }
};

// override so we can put in the hook for the old value
dhtmlXGridObject.prototype._in_header_text_filter = function(a, b) {
    a.innerHTML = "<input type='text'>";
    a.onclick = a.onmousedown = function(a) {
        return (a || event).cancelBubble = !0
    };
    a.onselectstart = function() {
        return event.cancelBubble = !0
    };
    var sa = $('input', $(a)).get(0);
    this.attachEvent('CF_onFiltersUpdated', function() {
    	sa.old_value = sa.value;
    });
    this.makeFilter(a.firstChild, b);
}
dhtmlXGridObject.prototype._in_header_error_filter = function(t, i) {
    this._in_header_text_filter.call(this, t, i);
    t.firstChild.style.display = 'none';
    t.firstChild._filter = function() {
        var v = this.value;
        if (v == '') return '';
        return function(val) {
        	return val != '';
        }
    };
}
dhtmlXGridObject.prototype._in_header_global_filter = function(t, i) {
    this._in_header_text_filter.call(this, t, i);
    var g = this;

    t.firstChild._filter = function() {
        var v = this.value;
        if (v == '') return '';
        v = v.toLocaleLowerCase();

        var lastIndexFound = -1;

		// build a map here to speed things up
		var iddToTbl = g.CF_getAllBackingDataById();

       	return function(val) {
       		// val is the row Id
       		var rec = iddToTbl[val];
       		if (rec) {
       			// first try lastIndexFound
       			if (lastIndexFound >= 0) {
       				val = g.CF_getRowValueInCellRec(rec, lastIndexFound);
       				if (val != undefined && val != null) {
       					if (!val.indexOf) val = '' + val;
	       				if (val.toLocaleLowerCase().indexOf(v) >= 0) {
	       					return true;
	       				}
       				}
       			}
       			lastIndexFound = -1;
       			for (var i = 0; i < g.CF_fieldDef.length; i++) {
       				if (g.CF_fieldDef[i].dynamicFieldIndex == undefined) continue;
       				val = g.CF_getRowValueInCellRec(rec, i);
       				if (val == undefined || val == null) continue;
       				if (!val.indexOf) val = '' + val;
       				if (val.toLocaleLowerCase().indexOf(v) >= 0) {
       					lastIndexFound = i;
       					return true;
       				}
       			}
       		}
       		return false;
        };
    };
}
dhtmlXGridObject.prototype._in_header_date_filter = function(t, i) {
    this._in_header_text_filter.call(this, t, i);

    var td = function(d) {
    	var resetTime = d.indexOf(' ') < 0;
        d = Date.parse(d); // don't parse here using our custom routine since it can also be just year or month/year
        if (isNaN(d)) return false;
        d = new Date(d);
        if (resetTime) { d.setHours(0); d.setMinutes(0); d.setSeconds(0); d.setMilliseconds(0); }
        return d.getTime();
    }

    t.firstChild._filter = function() {
        var v = this.value;
        if (v == '') return '';

        var r;
        var op = "==";
        var vx = v.replace('=', '');
        if (vx == '') {
        	// only thing entered is = ...match on blank
        	return function(val) {
            	return val.toString() == '';
            };
        } else if (v == '<>') {
        	// only thing entered is <>...match on non-blank
        	return function(val) {
            	return val.toString() != '';
            };
        } else if (vx.length == 10 && !isNaN(parseInt(vx.charAt(0)))) {
        	// do a straight text compare - it's a date comparison
        	return function(val) {
            	return (val.toString().indexOf(t.firstChild.value) >= 0);
            };
        }
        var num = td(vx);
        var num2 = null;

        if (v.indexOf("..") != -1) {
            v = v.split("..");
            num = td(v[0]);
            num2 = td(v[1]);
            if (!num || !num2) return '';

            return function(v) {
                var dd = td(v);
                if (!dd) return false;
                return (dd >= num && dd <= num2);
            };
        }
        r = v.match(/>=|<=|<>|>|</)
        if (r) {
            op = r[0];
            if (op == '<>') op = '!=';
            num = td(v.replace(op, ""));
            if (!num) return '';
        }
        return Function("v", "if (isNaN($.parseDateTime(v))) return false; var d = new Date($.parseDateTime(v)); if (v.indexOf(' ') < 0) { d.setHours(0); d.setMinutes(0); d.setSeconds(0); d.setMilliseconds(0); } return d.getTime() " + op + " " + num + ";");
    };
}
dhtmlXGridObject.prototype._in_header_textregex_filter = function(a, b) {
    a.innerHTML = "<select style='width: 90%;' class='filter_prop'><option value=''><option value='sw'>{!$Label.grid_filter_startswith}<option value='ew'>{!$Label.grid_filter_endswith}<option value='eq'>{!$Label.grid_filter_equals}<option value='ne'>{!$Label.grid_filter_notequals}<option value='c'>{!$Label.grid_filter_contains}<option value='nc'>{!$Label.grid_filter_notcontains}</select> <input type='text' style='width:90%; font-size:8pt; font-family:Tahoma; -moz-user-select:text; '>";
    a.onclick = a.onmousedown = function(a) {
        return (a || event).cancelBubble = !0
    };
    a.onselectstart = function() {
        return event.cancelBubble = !0
    };
    var s = $('input', $(a));
    var sa = s.get(0);
    var c = this;

    if (!this.filters) this.filters = new Array();
    this.filters.push([sa, b]);
    sa.value = "";
    sa.onkeydown = function() {
        this._timer && window.clearTimeout(this._timer);
        this._timer = window.setTimeout(function() {
            if (sa.value != sa.old_value)
            c.filterByAll(), sa.old_value = sa.value
        }, 500)
    };
    this.attachEvent('CF_onFiltersUpdated', function() {
    	sa.old_value = sa.value;
    });

    s = $('.filter_prop', $(a));
    var sad = s.get(0);
    sad.onchange = function() {
        $(sa).attr('filter_prop', this.value);
        c.filterByAll();
    };

    sa._filter = function() {
        var t = $(this);
        var origV = t.val();
        var v = origV.toLocaleLowerCase();
        var p = t.attr('filter_prop');
        if (p == undefined) p = '';

        var or_arr = false;
        var and_arr = false;
        var regex = false;
        if (v != '' && p == '') {
        	if (v.beginsWith('/')) {
        		try {
	        		var modifiers = origV.lastIndexOf('/');
    	    		regex = origV.substring(1, modifiers);
        			modifiers = origV.substring(modifiers + 1);
        			regex = new RegExp(regex, modifiers);
        		} catch(e) {
        			// invalid regex
        		}
        	} else {
	            or_arr = [];
	            and_arr = [];
	            var t_arr = v.split('|');
	            for (var i = 0; i < t_arr.length; i++) {
	                t_arr[i] = $.trim(t_arr[i]);
	                if (t_arr[i] == '') continue;
	                or_arr.push(t_arr[i]);
	            }
	            t_arr = v.split('&');
	            for (var i = 0; i < t_arr.length; i++) {
	                t_arr[i] = $.trim(t_arr[i]);
	                if (t_arr[i] == '') continue;
	                and_arr.push(t_arr[i]);
	            }
	        }
        }
        return function(d, idd) {
            // return false to remove, true to keep this record based on the filter
            if (v == '') {
                if (p == 'eq') return d == '';
                if (p == 'ne') return d != '';
                return true;
            }

            // if picklist, get the display value - d right now would be the backend value (for Divisions it matters)
            if (c.CF_fieldDef[b]['PicklistVals']) {
                for (var i = 0; i < c.CF_fieldDef[b]['PicklistVals'].length; i++) {
                    if (c.CF_fieldDef[b]['PicklistVals'][i].value == d) {
                        d = c.CF_fieldDef[b]['PicklistVals'][i].label;
                        break;
                    }
                }
            }
            var origD = d;
            d = d.toLocaleLowerCase();

			if (p == '') {
				if (regex) {
					return origD.match(regex) != null;
				} else if (or_arr && or_arr.length > 1) {
                    for (var i = 0; i < or_arr.length; i++) {
                    	if (or_arr[i].charAt(0) == '~') {
                    		if ($.fuzzyMatchKeywords(or_arr[i].substring(1), d)) return true;
                    	} else {
                        	if (d.indexOf(or_arr[i]) >= 0) return true;
                        }
                    }
                    return false;
                } else if (and_arr && and_arr.length > 1) {
                    for (var i = 0; i < and_arr.length; i++) {
	                   	if (and_arr[i].charAt(0) == '~') {
	                   		if (!$.fuzzyMatchKeywords(and_arr[i].substring(1), d)) return false;
	                   	} else {
	                       	if (d.indexOf(and_arr[i]) < 0) return false;
	                    }
                    }
                    return true;
                } else {
                   	if (v.charAt(0) == '~') {
                   		if ($.fuzzyMatchKeywords(v.substring(1), d)) return true;
                   	} else {
                       	if (d.indexOf(v) >= 0) return true;
                   }
                }
			}
			else if (p == 'c') return (d.indexOf(v) >= 0);
            else if (p == 'eq') return d == v;
            else if (p == 'ne') return d != v;
            else if (p == 'sw') return d.indexOf(v) == 0;
            else if (p == 'ew') {
                var x = d.length - v.length;
                return x >= 0 && d.lastIndexOf(v) === x;
            }
            else if (p == 'nc') return d.indexOf(v) == -1;
            return false;
        };
    }
    this._filters_ready();
};
dhtmlXGridObject.prototype._in_header_plist_filter = function(a, b, c) {
    a.innerHTML = c[0] + "<select style='width: 90%' class='filter_prop'></select><input type='text' class='hidden'>" + c[1];
    a.onclick = a.onmousedown = function(a) {
        return (a || event).cancelBubble = !0
    };
    a.onselectstart = function() {
        return event.cancelBubble = !0
    };
    var s = $('input', $(a));
    var sa = s.get(0);
    var c = this;

    if (!this.filters) this.filters = new Array();
    this.filters.push([sa, b]);
    sa.value = "";

    s = $('.filter_prop', $(a));
    s.append($.plistToSelect(this.CF_fieldDef[b]['PicklistVals'])).val('');
    s.append($('<option value="--BLANK--">--BLANK--</option>'));
    var sad = s.get(0);
    sad.onchange = function() {
        if (this.selectedIndex == 0) {
            $(sa).removeAttr('filter_prop');
        } else {
            $(sa).attr('filter_prop', this.selectedIndex == this.options.length - 1 ? '' : this.value);
        }
        $(sa).val(this.value);
        c.filterByAll();
    };

    sa._filter = function() {
        var t = $(this);
        var p = t.attr('filter_prop');
        var sel_all = p == undefined;
        return function(d) {
            // return false to remove, true to keep this record based on the filter
            return sel_all ? true : d == p;
        };
    }
    this._filters_ready();
}
dhtmlXGridObject.prototype._in_header_yesno_filter = function(a, b, c) {
    a.innerHTML = c[0] + "<select><option value='' /><option value='1'>Yes</option><option value='0'>No</option></select>" + c[1];
    a.onclick = function(a) {
        (a || event).cancelBubble = !0;
        return !1
    };
    var d = this;
    var s = $('select', $(a));
    var sa = s.get(0);
    if (!sa.style.width) sa.style.width = "90%";
    
    if (!this.filters) this.filters = new Array();
    this.filters.push([sa, b]);
    if (_isIE) sa.style.marginTop = "1px";
    s.change(function() {
        d.filterByAll();
    });
    this._filters_ready();
}
dhtmlXGridObject.prototype._in_header_master_rah_checkbox = function(a, b, c) {
    a.innerHTML = c[0] + "<input class='master_checkbox' type='checkbox' />" + c[1];
    var d = this;
    a.getElementsByTagName("input")[0].onclick = function(a) {
        d._build_m_order();
        var c = d._m_order ? d._m_order[b] : b, g = this.checked ? 1 : 0;

        // go through each row in the buffer and see if we need to check it
        var rec;
        var updatedLines = {};
        for (var i = 0; i < d.rowsBuffer.length; i++) {
            rec = d.CF_getBufferSequenceRec(i);
            updatedLines[rec.idd] = 1;
            d.CF_setValueInCellRec(rec, c, g);
        }
        
        var fullList = d.CF_getAllBackingDataById();
        for (var f in fullList) {
        	if (updatedLines[f]) continue;
        	var xx = d.CF_getValueFromCellRec(fullList[f], c);
        	if (xx != '0') {
        		d.CF_setValueInCellRec(fullList[f], c, 0);
        	}
        }
        
        (a || event).cancelBubble = !0
    }
};

/***** stat methods ******/
dhtmlXGridObject.prototype._in_header_stat_min = function(a, b, c) {
	var g = this;
	var getVal = function(buff, c) {
		if (g.CF_fieldDef[c].soapType == 'DATE' || g.CF_fieldDef[c].soapType == 'DATETIME') {
			return $.parseDateTime(g._get_cell_value(buff, c));
		} else {
			return parseFloat(g._get_cell_value(buff, c));
		}
	};
	var formatVal = function(val, c) {
		if (val === false) return '';
		if (g.CF_fieldDef[c].soapType == 'DATETIME') {
			return $.formatDateTime(new Date(val));
		} else if (g.CF_fieldDef[c].soapType == 'DATE') {
			return $.formatDate(new Date(val));
		} else {
			return g._maskArr[c] ? g._aplNF(val, c) : val;
		}
	}
    var d = function() {
        var a = false;
		var tmpVal;
	    this._build_m_order();
        var c = this._m_order ? this._m_order[b] : b;
		if (!this.CF_isInGroupMode()) {
			for (var i = 0; i < this.rowsBuffer.length; i++) {
				tmpVal = getVal(this.rowsBuffer[i], c);
				if (isNaN(tmpVal)) continue;
				a = a === false ? tmpVal : Math.min(a, tmpVal);
			}
		} else {
	    	var pids = {};
	        var pid = false;
	        this._h2.forEachChild(0, function(r) {
	        	if ($.isGroupId(r.id)) return;
	        	pid = this.getParentId(r.id);
	        	if (!pids[pid] && pids[pid] !== false) pids[pid] = false;

				tmpVal = getVal(r.buff || this.rowsAr[r.id], c);
				if (isNaN(tmpVal)) return;
				pids[pid] = pids[pid] === false ? tmpVal : Math.min(pids[pid], tmpVal);
	            a = a === false ? tmpVal : Math.min(a, tmpVal);
	        }, this);
	        while (true) {
	        	if ($.isEmptyObject(pids)) break;
	        	var tmpPids = pids;
	        	pids = {};
	        	for (var id in tmpPids) {
	        		this.CF_setValueInCellRec(this.CF_getByIdFromBackingData(id), c, formatVal(tmpPids[id], c));

	        		pid = this.getParentId(id);
	        		if (pid == null || pid == '') continue;
	        		if (!pids[pid] && pid !== false) pids[pid] = false;
	        		pids[pid] = pids[pid] === false ? tmpPids[id] : Math.min(pids[pid], tmpPids[id]);
				}
	        }
		}
		return formatVal(a, c);
    };
    this._stat_in_header(a, d, b, c)
};
dhtmlXGridObject.prototype._in_header_stat_max = function(a, b, c) {
	var g = this;
	var getVal = function(buff, c) {
		if (g.CF_fieldDef[c].soapType == 'DATE' || g.CF_fieldDef[c].soapType == 'DATETIME') {
			return $.parseDateTime(g._get_cell_value(buff, c));
		} else {
			return parseFloat(g._get_cell_value(buff, c));
		}
	};
	var formatVal = function(val, c) {
		if (val === false) return '';
		if (g.CF_fieldDef[c].soapType == 'DATETIME') {
			return $.formatDateTime(new Date(val));
		} else if (g.CF_fieldDef[c].soapType == 'DATE') {
			return $.formatDate(new Date(val));
		} else {
			return g._maskArr[c] ? g._aplNF(val, c) : val;
		}
	}
    var d = function() {
        var a = false;
		var tmpVal;
	    this._build_m_order();
        var c = this._m_order ? this._m_order[b] : b;
		if (!this.CF_isInGroupMode()) {
			for (var i = 0; i < this.rowsBuffer.length; i++) {
				tmpVal = getVal(this.rowsBuffer[i], c);
				if (isNaN(tmpVal)) continue;
				a = a === false ? tmpVal : Math.max(a, tmpVal);
			}
		} else {
	    	var pids = {};
	        var pid = false;
	        this._h2.forEachChild(0, function(r) {
	        	if ($.isGroupId(r.id)) return;
	        	pid = this.getParentId(r.id);
	        	if (!pids[pid] && pids[pid] !== false) pids[pid] = false;

				tmpVal = getVal(r.buff || this.rowsAr[r.id], c);
				if (isNaN(tmpVal)) return;
				pids[pid] = pids[pid] === false ? tmpVal : Math.max(pids[pid], tmpVal);
	            a = a === false ? tmpVal : Math.max(a, tmpVal);
	        }, this);
	        while (true) {
	        	if ($.isEmptyObject(pids)) break;
	        	var tmpPids = pids;
	        	pids = {};
	        	for (var id in tmpPids) {
	        		this.CF_setValueInCellRec(this.CF_getByIdFromBackingData(id), c, formatVal(tmpPids[id], c));

	        		pid = this.getParentId(id);
	        		if (pid == null || pid == '') continue;
	        		if (!pids[pid] && pid !== false) pids[pid] = false;
	        		pids[pid] = pids[pid] === false ? tmpPids[id] : Math.max(pids[pid], tmpPids[id]);
				}
	        }
		}
		return formatVal(a, c);
    };
    this._stat_in_header(a, d, b, c)
};
dhtmlXGridObject.prototype._in_header_stat_count = function(a, b, c) {
    var d = function() {
        var a = 0;
	    this._build_m_order();
        var c = this._m_order ? this._m_order[b] : b;

    	if (!this.CF_isInGroupMode()) {
    		a = this.getRowsNum();
    	} else {
	    	var pids = {};
	        var pid = false;
	        this._h2.forEachChild(0, function(r) {
	        	if ($.isGroupId(r.id)) return;
	        	pid = this.getParentId(r.id);
	        	if (!pids[pid]) pids[pid] = 0;
	            pids[pid]++;
	            a++;
	        }, this);
	        while (true) {
	        	if ($.isEmptyObject(pids)) break;
	        	var tmpPids = pids;
	        	pids = {};
	        	for (var id in tmpPids) {
	        		this.CF_setValueInCellRec(this.CF_getByIdFromBackingData(id), c, tmpPids[id]);

	        		pid = this.getParentId(id);
	        		if (pid == null || pid == '') continue;
	        		if (!pids[pid]) pids[pid] = 0;
	        		pids[pid] += tmpPids[id];
				}
	        }
    	}
    	return a;
    };
    this._stat_in_header(a, d, b, c)
};
dhtmlXGridObject.prototype._in_header_stat_average = function(a, b, c) {
    var d = function() {
	    this._build_m_order();
        var c = this._m_order ? this._m_order[b] : b;
        var x = 0, y = 0, avg = 0; // sum then count
		if (!this.CF_isInGroupMode()) {
	        for (d = 0; d < this.rowsBuffer.length; d++) {
	            var h = parseFloat(this._get_cell_value(this.rowsBuffer[d], c));
	            x += isNaN(h) ? 0 : h;
	            y++;
	        }
		} else {
	    	var pids = {};
	        var pid = false;
	        this._h2.forEachChild(0, function(r) {
	        	if ($.isGroupId(r.id)) return;
	        	pid = this.getParentId(r.id);
	        	if (!pids[pid]) pids[pid] = {x: 0, y: 0};
	            var d = parseFloat(this._get_cell_value(r.buff || this.rowsAr[r.id], c));
	            d = isNaN(d) ? 0 : d;
	            pids[pid]['x'] += d;
	            pids[pid]['y'] ++;
	            x += d;
	            y++;
	        }, this);
	        while (true) {
	        	if ($.isEmptyObject(pids)) break;
	        	var tmpPids = pids;
	        	pids = {};
	        	for (var id in tmpPids) {
	        		avg = tmpPids[id]['y'] == 0 ? 0 : tmpPids[id]['x'] / tmpPids[id]['y'];
	        		this.CF_setValueInCellRec(this.CF_getByIdFromBackingData(id), c, this._maskArr[c] ? this._aplNF(avg, c) : Math.round(avg * 100) / 100);

	        		pid = this.getParentId(id);
	        		if (pid == null || pid == '') continue;
	        		if (!pids[pid]) pids[pid] = {x: 0, y: 0};
	        		pids[pid]['x'] += tmpPids[id]['x'];
	        		pids[pid]['y'] += tmpPids[id]['y'];
				}
	        }
		}

		avg = y == 0 ? 0 : x / y;
        return this._maskArr[c] ? this._aplNF(avg, c) : Math.round(avg * 100) / 100;
    };
    this._stat_in_header(a, d, b, c)
};
dhtmlXGridObject.prototype._in_header_stat_total = function(a, b, c) {
    var d = function() {
        var a = 0;
	    this._build_m_order();
        var c = this._m_order ? this._m_order[b] : b;
    	if (!this.CF_isInGroupMode()) {
	        for (d = 0; d < this.rowsBuffer.length; d++) {
	            var h = parseFloat(this._get_cell_value(this.rowsBuffer[d], c));
	            a += isNaN(h) ? 0 : h
	        }
	    } else {
	    	var pids = {};
	        var pid = false;
	        this._h2.forEachChild(0, function(r) {
	        	if ($.isGroupId(r.id)) return;
	        	pid = this.getParentId(r.id);
	        	if (!pids[pid]) pids[pid] = 0;
	            var d = parseFloat(this._get_cell_value(r.buff || this.rowsAr[r.id], c));
	            d = isNaN(d) ? 0 : d;
	            pids[pid] += d;
	            a += d;
	        }, this);
	        while (true) {
	        	if ($.isEmptyObject(pids)) break;
	        	var tmpPids = pids;
	        	pids = {};
	        	for (var id in tmpPids) {
	        		this.CF_setValueInCellRec(this.CF_getByIdFromBackingData(id), c, this._maskArr[c] ? this._aplNF(tmpPids[id], c) : Math.round(tmpPids[id] * 100) / 100);

	        		pid = this.getParentId(id);
	        		if (pid == null || pid == '') continue;
	        		if (!pids[pid]) pids[pid] = 0;
	        		pids[pid] += tmpPids[id];
				}
	        }
	    }
        return this._maskArr[c] ? this._aplNF(a, c) : Math.round(a * 100) / 100
    };
    this._stat_in_header(a, d, b, c)
};
/**** end stat methods ***/

dhtmlXGridObject.prototype.CF_getBufferSequenceRec = function(seq) {
    return this.rowsBuffer[seq];
}
dhtmlXGridObject.prototype.CF_getValueFromCellRec = function(rec, cIndex) {
    if (rec._parser) {
        // not yet rendered
        return rec['data']['data'][cIndex];
    } else {
        // rendered - return value from cells - this way we get the split value as well
        return this.cells(rec.idd, cIndex).getValue();
    }
}
dhtmlXGridObject.prototype.CF_setValueInCellRec = function(rec, cIndex, text) {
	if (rec == undefined) return;
    if (rec._parser) {
        rec['data']['data'][cIndex] = text;
    } else {
        // the first way updates it in the split cell (if there's one)...the 2nd way updates it in the master cell
        this.cells(rec.idd, cIndex).setValue(text);
        this.cells4(this.rowsAr[rec.idd].childNodes[cIndex]).setValue(text);
        this.CF_setValueInTreeCacheHack(rec.idd, cIndex, text);
    }
}
dhtmlXGridObject.prototype.CF_setValueInTreeCacheHack = function(rid, cindex, new_value) {
	if (this.isTreeGrid()) {
     	// there's a bug where the data cache in treegrid doesn't get updated - take care of it here since otherwise filters won't work
     	if (this._f_rowsBuffer) {
     		var rw = this._f_rowsBuffer.get[rid];
     		if (rw.buff && rw.buff.data && rw.buff.data.data) {
     			rw.buff.data.data[cindex] = new_value;
     		}
     	}

   		var rw = this._h2.get[rid];
   		if (rw.buff && rw.buff.data && rw.buff.data.data) {
   			rw.buff.data.data[cindex] = new_value;
   		}
	}
}
dhtmlXGridObject.prototype.CF_getCheckedRowsVisible = function() {
    // returns only records visible through any filters applied
    var rec;
    var ret = [];
    var val;
    var checkInd = this.CF_indexByField['__selectall'];
    var checkHidden = this.getColWidth(checkInd) == 0;
    for (var i = 0; i < this.rowsBuffer.length; i++) {
        rec = this.CF_getBufferSequenceRec(i);
        val = checkHidden ? '1' : this.CF_getValueFromCellRec(rec, this.CF_indexByField['__selectall']);
        if (val == '1') ret.push(i);
    }
    return ret;
}
dhtmlXGridObject.prototype.CF_getRowsVisible = function() {
	var ret = [];
    for (var i = 0; i < this.rowsBuffer.length; i++) {
        ret.push(i);
    }
    return ret;
}
dhtmlXGridObject.prototype.CF_isRowRendered = function(rid) {
    return this.rowsAr[rid] != undefined && this.rowsAr[rid].tagName == 'TR';
}
dhtmlXGridObject.prototype.CF_getAllBackingDataById = function() {
	var iddToTbl = {};
	for (var i = 0; i < this.rowsBuffer.length; i++) {
		iddToTbl[this.rowsBuffer[i].idd] = this.rowsBuffer[i];
   	}
    if (this._f_rowsBuffer) {
        for (var i = 0; i < this._f_rowsBuffer.length; i++) {
        	if (iddToTbl[this._f_rowsBuffer[i].idd]) continue;
        	iddToTbl[this._f_rowsBuffer[i].idd] = this._f_rowsBuffer[i];
        }
    }
    if (this.rowsAr) {
    	for (var idd in this.rowsAr) {
    		if (iddToTbl[idd] || !this.rowsAr[idd]) continue;
    		iddToTbl[idd] = this.rowsAr[idd];
    	}
    }
    return iddToTbl;
}
dhtmlXGridObject.prototype.CF_getByIdFromBackingData = function(idd) {
    // _f_rowsBuffer is the master list while filtered, but it might contain reference to a record that is rendered in rowsBuffer
    // so if it's rendered in rowsBuffer, return that first
    for (var i = 0; i < this.rowsBuffer.length; i++) {
        if (this.rowsBuffer[i].idd == idd) return this.rowsBuffer[i];
    }
    if (this._f_rowsBuffer) {
        for (var i = 0; i < this._f_rowsBuffer.length; i++) {
            if (this._f_rowsBuffer[i].idd == idd) return this._f_rowsBuffer[i];
        }
    }
    // worst case - have to return it somehow in the case where it's a tree and hidden but not filtered out
    if (this.rowsAr) {
    	return this.rowsAr[idd];
    }
}

dhtmlXGridObject.prototype.CF_getRowValueInCell = function(rid, cindex) {
    var s = this.CF_getByIdFromBackingData(rid);
    return this.CF_getRowValueInCellRec(s, cindex);
}
dhtmlXGridObject.prototype.CF_getRowValueInCellRec = function(rec, cindex) {
    if (rec._parser) { 
        return rec['data']['data'][cindex];
    } else {
        return this.cells(rec.idd, cindex).getValue();
    }
}
dhtmlXGridObject.prototype.CF_rowCreatedInGrid = function(rid, rObj, rXML) {
    if ($.isGroupId(rid)) {
    	// replace everything not grouped with "ro"
    	for (var i = this.CF_getDynamicBeginFieldIndex(); i < this.CF_fieldDef.length; i++) {
    		if (!this.CF_fieldDef[i]['group']) {
	    		this.setCellExcellType(rid, i, this.CF_fieldDef[i]['summary'] ? 'ro' : 'blank');
	    		this.setCellTextStyle(rid, i, 'text-align: right');
	    	}
    	}
    } else if (!this.CF_loadComplete) {
    	// don't care about ones that are initially being rendered
    } else {
    	// do this for temporary (NEW) records as well
	    // if there's an _ in the row ID, then it's as a result of a drag/drop...
	    var c = this.getRowById(rid);
	    var hasError = false;
	    if (this.CF_indexByField['__error']) {
	        hasError = this.cells3(c, this.CF_indexByField['__error']).getValue() != '';
	    }
	    var orig_rid = (rid.split('_'))[0];
	    var isTemp = $.isTemporaryId(rid);

	    for (var i = 0; i < this.CF_fieldDef.length; i++) {
	        if (this.CF_fieldDef[i]['skip_track_changes']) continue;
	        var v = this.cells3(c, i).getPlainValue(this.CF_fieldDef[i]['type']);

			// checkboxes have a value of 0 by default and not empty - so if it's a new record and set to 0, don't look at it
	        if (isTemp && v === '0' && (this.CF_fieldDef[i]['type'] == 'ch' || this.CF_fieldDef[i]['type'] == 'chro')) {
	        	v = '';
	        }
	        if (isTemp ? v : v != this.CF_dataById[orig_rid][i]) {
	        	// skip the dirty flag when this is a drop row since the user fields will be copied over
	            this.CF_setWasChanged(rid, i, true, hasError, orig_rid != rid);
	        }
	    }
	    if (this.CF_getUserData(orig_rid, 'deleted')) {
	        this.setRowTextStyle(rid,"text-decoration : line-through;");
	    }
    }
    return true;
}
dhtmlXGridObject.prototype.CF_getGridCheckedRows = function() {
    var sel = this.CF_getCheckedRowsVisible();
    if (sel.length == 0) {
        alert('Please check one or more records to continue.');
    }
    return sel;
}

// replace to add logic to throw exception on empty responses - getting an error when SF returns null
if (window['Visualforce']) {
    var rps = Visualforce.remoting.RemotingProvider;
    if (!rps) {
        rps = [];
        for (var i in Visualforce.remoting.Manager.providers) {
            rps.push(Visualforce.remoting.Manager.providers[i]);
        }
    } else rps = [rps];

    for (var i = 0; i < rps.length; i++) {
        var rp = rps[i];
        rp.onDataOld = rp.onData;
        rp.onData = function(e, k, d) {
        	var xa = window['_Visualforce'] ? window['_Visualforce'] : window['VFExt3'];
            if (k && xa.isEmpty(d.responseText)) k = false;
            if (k) {
                // make sure session is not expired
                if (d.responseText.length > 3 && d.responseText.substring(0, 3) == '\r\n<') {
                    alert('Your session is expired.  You will now be redirected back to the login screen.');
                    window.top.location = '/';
                    return;
                }
            }
            this.onDataOld(e, k, d);
        }
        rp.maxRetries = 3;
        rp.timeout = 45000;
        rp.enableBuffer = 0;
        rp.addListener('beforecall', function(impl, trans, i) {
            // set specific properties in the search request...?
            if (lastIdBatch.length > 0) trans.lastIdBatch = lastIdBatch;
        });
    }
}

function getIDBatchForEvent(e) {
    if (e == null) alert('An unknown error occurred');
    if (e.transaction && e.transaction.lastIdBatch) {
        if (!e.transaction.lastIdBatch.length) {
            // object - convert to an array
            var arr = [];
            for (var i = 0; i >= 0; i++) {
                if (e.transaction.lastIdBatch[i]) {
                    arr[i] = e.transaction.lastIdBatch[i];
                } else break;
            }
        }
        return arr;
    }
    var rps = Visualforce.remoting.RemotingProvider;
    if (!rps) {
        rps = [];
        for (var i in Visualforce.remoting.Manager.providers) {
            rps.push(Visualforce.remoting.Manager.providers[i]);
        }
    } else rps = [rps];
    for (var i = 0; i < rps.length; i++) {
        var xx = rps[i].getTransaction(e);
        if (xx && xx.lastIdBatch) return xx.lastIdBatch;
    }
}

/** extraction functions **/

var postLookupFunc;

$.CF_clone = function(item) {
    if (!item) { return item; } // null, undefined values check

    var types = [ Number, String, Boolean ], 
        result;

    // normalizing primitives if someone did new String('aaa'), or new Number('444');
    types.forEach(function(type) {
        if (item instanceof type) {
            result = type( item );
        }
    });

    if (typeof result == "undefined") {
        if (Object.prototype.toString.call( item ) === "[object Array]") {
            result = [];
            item.forEach(function(child, index, array) { 
                result[index] = $.CF_clone( child );
            });
        } else if (typeof item == "object") {
            // testing that this is DOM
            if (item.nodeType && typeof item.cloneNode == "function") {
                var result = item.cloneNode( true );    
            } else if (!item.prototype) { // check that this is a literal
                if (item instanceof Date) {
                    result = new Date(item);
                } else {
                    // it is an object literal
                    result = {};
                    for (var i in item) {
                        result[i] = $.CF_clone( item[i] );
                    }
                }
            } else {
                // depending what you would like here,
                // just keep the reference, or create new object
                if (false && item.constructor) {
                    // would not advice to do that, reason? Read below
                    result = new item.constructor();
                } else {
                    result = item;
                }
            }
        } else {
            result = item;
        }
    }

    return result;
}
$.CF_doLookup = function(vfUrl, selectFunc, initFunc) {
   vfUrl = $.CF_getApexURL(vfUrl);

   var ifr = $('<iframe style="width: 100%; height: 100%; border: 0px" />').attr('src', vfUrl);
   ifr.get(0).selectFunc = selectFunc;
   ifr.get(0).initFunc = initFunc;
   $('#CF_lookupDialog').html(ifr).dialog('open');
}
$.CF_doChatterFileSelect = function(dlg, publisher, a, c) {
   var d = '';
   if (c) d = '?cc=true';
   var ifr = $('<iframe style="width: 100%; height: 100%; border: 0px" />').attr('src', '/_ui/content/view/files/sharing/FindLinkedFilesPage' + d);
   $('#CF_chatterFileSelectDialog').html(ifr).dialog('open');
   window['chatter'] = { getPublisher: function() {
    dlg.show();
    $('#CF_chatterFileSelectDialog').dialog('close');
    return publisher;
   }};
}
$.CF_cancelLookup = function() {
   $('#CF_lookupDialog').dialog('close');
}
$.fn.serializeObject = function() {
    var o = {};
    var a = this.serializeArray();
    $.each(a, function() {
        if (this.value == '') return;
        if (o[this.name] !== undefined) {
            if (!o[this.name].push) {
                o[this.name] = [o[this.name]];
            }
            o[this.name].push(this.value || '');
        } else {
            o[this.name] = this.value || '';
        }
    });
    return o;
};
$.strToBool = function(x) {
	if (x === true) x = true;
    else if (!x || x.toLocaleLowerCase() == 'false' || x.toLocaleLowerCase() == 'n' || x.toLocaleLowerCase() == 'no' || x.toLocaleLowerCase() == 'f' || x == '0') x = false;
    else x = true;
	return x;
}
$.isNumeric = function(x) {
    return !isNaN(parseFloat(x)) && isFinite(x);
}
$.isLiveId = function(rid) {
	return rid && rid != '' && !$.isTemporaryId(rid) && !$.isGroupId(rid);
}
$.isGroupId = function(rid) {
	return rid.beginsWith('_grp_');
}
$.isTemporaryId = function(rid) {
    return rid.charAt(0) == '-';
}
$.formatNumber = function(val) {
    return $('<div />').text('' + val).digits().text();
}
$.formatDateTime = function(d, format) {
	if (!format) format = $.getDateFormat().replace('yyyy', 'yy').toLowerCase();
    var hh = d.getHours();
    var ampm = 'am';
    if (hh == 0) {
        hh = 12;
    } else if (hh >= 12) {
        ampm = 'pm';
        if (hh > 12) hh -= 12;
    }
    hh = '0' + hh;
    hh = hh.substring(hh.length - 2);
    var mm = '0' + d.getMinutes();
    mm = mm.substring(mm.length - 2);

    return $.datepicker.formatDate(format, d) + ' ' + hh + ':' + mm + ' ' + ampm;
}
// opposite of $.formatDateTime
$.parseDateTime = function(s) {
	if (!s) return NaN;
	var x = s.lastIndexOf(':');
	if (x < 0) {
		// maybe just a date - return parseDate instead - we do this safety net because things like sort and filter rely on this route
		return $.parseDate(s);
	}
	x = s.lastIndexOf(' ', x);
	var dx = s.substring(0, x);
	var d = $.datepicker.parseDate($.getDateFormat().replace('yyyy', 'yy').toLowerCase(), dx);
	s = s.substring(x + 1).split(' ');
	var ampm = s[1];
	s = s[0].split(':');
	s[0] = parseInt(s[0], 10);
	s[1] = parseInt(s[1], 10);
	if (s[0] == 12) s[0] = 0;
	if (ampm == 'pm') s[0] += 12;
	return new Date(d.getFullYear(), d.getMonth(), d.getDate(), s[0], s[1], 0, 0);
}
$.formatDate = function(d, format) {
	if (!format) format = $.getDateFormat().replace('yyyy', 'yy').toLowerCase();
	return $.datepicker.formatDate(format, d);
}
// opposite of $.formatDate
$.parseDate = function(s) {
	if (!s) return NaN;
	return $.datepicker.parseDate($.getDateFormat().replace('yyyy', 'yy').toLowerCase(), s);
}
$.CSVToArray = function(strData, strDelimiter, rowstoread) {
    // Check to see if the delimiter is defined. If not,
    // then default to comma.
    strDelimiter = (strDelimiter || ",");

    // Create a regular expression to parse the CSV values.
    var objPattern = new RegExp(
        (
            // Delimiters.
            "(\\" + strDelimiter + "|\\r?\\n|\\r|^)" +
    
            // Quoted fields.
            "(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|" +
    
            // Standard fields.
            "([^\"\\" + strDelimiter + "\\r\\n]*))"
        ), "gi"
    );

    // Create an array to hold our data. Give the array a default empty first row.
    var arrData = [[]];

    // Create an array to hold our individual pattern matching groups.
    var arrMatches = null;

    // Keep looping over the regular expression matches until we can no longer find a match.
    var numread = 0;
    while (arrMatches = objPattern.exec( strData )) {
            // Get the delimiter that was found.
            var strMatchedDelimiter = arrMatches[ 1 ];

            // Check to see if the given delimiter has a length (is not the start of string) and if it matches
            // field delimiter. If id does not, then we know that this delimiter is a row delimiter.
            if ( strMatchedDelimiter.length && (strMatchedDelimiter != strDelimiter)){
                 numread++;
                 if (rowstoread && rowstoread == numread) break;
                 // Since we have reached a new row of data,
                 // add an empty row to our data array.
                 arrData.push( [] );
            }

            // Now that we have our delimiter out of the way, let's check to see which kind of value we captured (quoted or unquoted).
            if (arrMatches[ 2 ]) {
                // We found a quoted value. When we capture this value, unescape any double quotes.
                var strMatchedValue = arrMatches[ 2 ].replace(new RegExp( "\"\"", "g" ), "\"" );
            } else {
                // We found a non-quoted value.
                var strMatchedValue = arrMatches[ 3 ];
            }

            // Now that we have our value string, let's add it to the data array.
            arrData[ arrData.length - 1 ].push( strMatchedValue );
    }

    // Return the parsed data.
    return arrData;
}
$.escapeCSV = function(str, delim) {
	if (!delim) delim = ',';
    if (str == null || str == undefined || str == '') return '';
    if (str === false || str == 0) return '0';
    if (str === true || str == 1) return '1';
    // convert to string
    str = '' + str;
    if (str.indexOf('"') >= 0 || str.indexOf("\n") >= 0 || str.indexOf(delim) >= 0) {
        str = str.replace(/"/g,'""');
        str = '"' + str + '"';
    }
    return str;
}
$.parseXML = function(xmlString) {
	if( typeof window.DOMParser === "undefined" ){
	    window.DOMParser = function(){};
	 
	    window.DOMParser.prototype.parseFromString = function(str, contentType){
	        if(typeof ActiveXObject !== 'undefined'){
	            var xmldata = new ActiveXObject('MSXML.DomDocument');
	            xmldata.async = false;
	            xmldata.loadXML(str);
	            return xmldata;
	        } else if(typeof XMLHttpRequest !== 'undefined'){
	            var xmldata = new XMLHttpRequest;
	 
	            if(!contentType){
	                contentType = 'application/xml';
	            }
	 
	            xmldata.open('GET', 'data:' + contentType + ';charset=utf-8,' + encodeURIComponent(str), false);
	 
	            if(xmldata.overrideMimeType) {
	                xmldata.overrideMimeType(contentType);
	            }
	 
	            xmldata.send(null);
	            return xmldata.responseXML;
	        }
	    };
	}
	var parser = new DOMParser();
	return parser.parseFromString(xmlString , "text/xml");
}
$.escapeHTML = function(txt) {
    if (txt == undefined) txt = '';
    return $('<div />').text(txt).html();
}
$.unescapeHTML = function(html) {
    if (html == undefined) html = '';
    return $('<div />').html(html).text();
}
$.unescapeURL = function(param) {
    if (param == undefined) param = '';
    param = param.replace(/\+/g, ' '); 
    return unescape(param);
}
$.getPageBaseName = function() {
    var hr = document.location.href.split('?');
    hr = hr[0].split('/');
    return hr[hr.length - 1];
}
$.getUrlParam = function(pn, loc) {
    pn = escape($.unescapeURL(pn));
    var qs = null;
    if (!loc) loc = window.location.search;
    if (loc.search(pn) > -1) {
      qs = loc.substr(1, loc.length).split('&');
    }
    if (qs == null) return null;
    var retVal = [];
    for (var i = 0; i < qs.length; i++) {
        if (escape($.unescapeURL(qs[i].split('=')[0])) == pn) {
            retVal.push($.unescapeURL(qs[i].split('=')[1]));
        }
    }
    if (retVal.length == 0) return null;
    if (retVal.length == 1) return retVal[0];
    return retVal;
}
$.fn.digits = function() {
    return this.each(function() {
        $(this).text($(this).text().replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1,"));
    });
}
$.getDateFormat = function() {
	var templateDate = $('#cfTmplDate input').val();
	return templateDate.replace('1999', 'yyyy').replace('12', 'MM').replace('31', 'dd');
}
$.localeThousandsSeparator = function() {
    var templateNumber = $('#cfTmplNumber input').val();
    if (!templateNumber) {
    	alert('The permissions for Configero DataLoader do not seem to be set up correctly.');
    }
    // thousands separator is the second character - if it's a 2, then assume comma since it doesn't have one
    var thousandsSeparator = templateNumber.charAt(1);
    if (thousandsSeparator == '2') thousandsSeparator = ',';
    return thousandsSeparator;
}
$.localeDecimalSeparator = function() {
    var templateNumber = $('#cfTmplNumber input').val();
    var decimalSeparator = templateNumber.charAt(templateNumber.length - 3);
    if (decimalSeparator == '4') decimalSeparator = '.';
    return decimalSeparator;
}
$.plistToSelect = function(v) {
    var ret = $('<select />');
    ret.append(new Option('', ''));
    for (var i = 0; i < v.length; i++) {
        ret.append(new Option(v[i].label, v[i].value));
    }
    return ret.children();
}
$.downloadFile = function(data, name, type) {
	if (data === undefined) return;
    // make sure it's not too big
    if (data.length > 1024 * 1024 * 14) {
        alert("The file you're trying to download is too big.  Please limit the number of records and try again.");
    } else {
        $('#csvdownload_formdata').val(data);
        $('#csvdownload_type').val(type);
        $('#csvdownload_name').val(name);
        // redirect to the full URL because chrome loses the post on a 302
        // $('#csvdownload_form').attr('action', CF_NAMESPACE_PREFIX + 'Configero_CSVDownload').submit();
        $('#csvdownload_form').attr('action', CF_HOSTED_URL + '/apex/Configero_CSVDownload').submit();
    }
}
$.SF15to18 = function(id) {
    if (!id || id == '' || id.length == 18) return id;
    if (id.length != 15) return null;

    var suffix = "";
    for(var i = 0; i < 3; i++) {
        var flags = 0;
        for(var j = 0; j < 5; j++) {
            var c = id.charAt(i * 5 + j);
            if(c >= 'A' && c <= 'Z') {
                flags += 1 << j;
            }
        }
        if(flags <= 25) {
            suffix += "ABCDEFGHIJKLMNOPQRSTUVWXYZ".charAt(flags);
        } else {
            suffix += "012345".charAt(flags - 26);
        }
    }
    return id + suffix;
}
$.assocKeys = function(assoc) {
    var ret = [];
    if (assoc) {
        for (var key in assoc) {
            if (assoc.hasOwnProperty(key)) ret.push(key);
        }
    }
    return ret;
}
$.levenshtein = function( a, b ) {
    var i;
    var j;
    var cost;
    var d = new Array();

    if ( a.length == 0 ) return b.length;
    if ( b.length == 0 ) return a.length;

	for ( i = 0; i <= a.length; i++ ) {
		d[ i ] = new Array();
        d[ i ][ 0 ] = i;
    }

    for ( j = 0; j <= b.length; j++ ) {
        d[ 0 ][ j ] = j;
	}

    for ( i = 1; i <= a.length; i++ ) {
		for ( j = 1; j <= b.length; j++ ) {
			if ( a.charAt( i - 1 ) == b.charAt( j - 1 ) ) {
				cost = 0;
            } else {
				cost = 1;
            }

			d[ i ][ j ] = Math.min( d[ i - 1 ][ j ] + 1, d[ i ][ j - 1 ] + 1, d[ i - 1 ][ j - 1 ] + cost );

			if (i > 1 && j > 1 && a.charAt(i - 1) == b.charAt(j-2) && a.charAt(i-2) == b.charAt(j-1)) {
          		d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);
			}
        }
    }
	return d[ a.length ][ b.length ];
};
$.soundEx = function(WordString, LengthOption, CensusOption) {
      var TmpStr;
      var WordStr = "";
      var CurChar;
      var LastChar;
      var SoundExLen = 10;
      var WSLen;
      var FirstLetter;

      if(CensusOption) LengthOption = 4;

      if(LengthOption != undefined) SoundExLen = LengthOption;
      if(SoundExLen > 10) SoundExLen = 10;
      if(SoundExLen < 4) SoundExLen = 4;

      if(!WordString) return("");

      WordString = WordString.toUpperCase();

      WordStr = WordString.replace(/[^A-Z]/gi, " "); // rpl non-chars w space
      WordStr = WordStr.replace(/^\s*/g, "");     // remove leading space
      WordStr = WordStr.replace(/\s*$/g, "");     // remove trailing space

      if(!CensusOption) {
          WordStr = WordStr.replace(/DG/g, "G");     // Change DG to G
          WordStr = WordStr.replace(/GH/g, "H");     // Change GH to H
          WordStr = WordStr.replace(/GN/g, "N");     // Change GN to N
          WordStr = WordStr.replace(/KN/g, "N");     // Change KN to N
          WordStr = WordStr.replace(/PH/g, "F");     // Change PH to F
          WordStr = WordStr.replace(/MP([STZ])/g, "M$1"); // MP if fllwd by ST|Z
          WordStr = WordStr.replace(/^PS/g, "S");   // Chng leadng PS to S
          WordStr = WordStr.replace(/^PF/g, "F");   // Chng leadng PF to F
          WordStr = WordStr.replace(/MB/g, "M");    // Chng MB to M
          WordStr = WordStr.replace(/TCH/g, "CH");  // Chng TCH to CH
      }

      FirstLetter = WordStr.substr(0,1);

      if(FirstLetter == "H" || FirstLetter == "W") {
          TmpStr = WordStr.substr(1);
          WordStr = "-";
          WordStr += TmpStr;
      }

      // In properly done census SoundEx the H and W will be squezed out before performing the test for adjacent digits (this differs from how 'real' vowels are handled)
      if(CensusOption == 1) {
          WordStr = WordStr.replace(/[HW]/g, ".");
      }

      // Begin Classic SoundEx
      WordStr =  WordStr.replace(/[AEIOUYHW]/g, "0");
      WordStr = WordStr.replace(/[BPFV]/g, "1");
      WordStr = WordStr.replace(/[CSGJKQXZ]/g, "2");
      WordStr = WordStr.replace(/[DT]/g, "3");
      WordStr = WordStr.replace(/[L]/g, "4");
      WordStr = WordStr.replace(/[MN]/g, "5");
      WordStr = WordStr.replace(/[R]/g, "6");

      // Properly done census: squeze H and W out before doing adjacent digit removal.
      if(CensusOption == 1) {
          WordStr = WordStr.replace(/\./g, "");
      }

      // Remove extra equal adjacent digits
      WSLen = WordStr.length;
      LastChar = "";
      TmpStr = "";
      // removed v10c djr:  TmpStr = "-";  /* rplcng skipped first char */

      for(i = 0; i < WSLen; i++) {
          CurChar = WordStr.charAt(i);
          if(CurChar == LastChar) {
              TmpStr += " ";
          }
          else {
              TmpStr += CurChar;
              LastChar = CurChar;
          }
      }
      WordStr = TmpStr;

      WordStr = WordStr.substr(1);          /* Drop first letter code   */
      WordStr = WordStr.replace(/\s/g, ""); /* remove spaces            */
      WordStr = WordStr.replace(/0/g, "");  /* remove zeros             */
      WordStr += "0000000000";              /* pad with zeros on right  */

      WordStr = FirstLetter + WordStr;      /* Add first letter of word */

      WordStr = WordStr.substr(0,SoundExLen); /* size to taste     */

      return(WordStr);
};
$.CF_getApexURL = function(url) {
   // hack workaround for now - primarily for minigrid where the grid is embedded and SF keeps the /servlet/servlet.Integration URL
   if (document.location.href.indexOf('/servlet/') >= 0) {
   	url = '/apex/' + url;
   }
   return url;
}

$.fuzzyMatchKeywords = function(a, b) {
	var ret = $.fuzzyMatch(a, b, {'weight_length': 0, 'skipStopWords': true});
	return ret === false ? false : ret <= 2;
}
$.fuzzyMatch = function(a, b, params) {
    a = a.toLocaleLowerCase();
    b = b.toLocaleLowerCase();

	if (!params) params = {};

	// remove stop words
	var stopWords = {'a':1, 'an':1, 'and':1, 'are':1, 'as':1, 'at':1, 'be':1, 'but':1, 'by':1, 'for':1, 'if':1, 'in':1, 'into':1, 'is':1, 'it':1, 'no':1, 'not':1, 'of':1, 'on':1,
		'or':1, 'such':1, 'that':1, 'the':1, 'their':1, 'then':1, 'there':1, 'these':1, 'they':1, 'this':1, 'to':1, 'was':1, 'will':1, 'with':1};
	if (params['skipStopWords']) stopWords = {};

    var tmpWordsS1 = a.split(/[\s_-]+/);
    var tmpWordsS2 = b.split(/[\s_-]+/);

	var wordsS1 = new Array();
	var wordsS2 = new Array();
	for (var i = 0; i < tmpWordsS1.length; i++) {
		if (stopWords[tmpWordsS1[i]] || tmpWordsS1[i].length <= 2) continue;
		wordsS1.push(tmpWordsS1[i]);
	}
	for (var i = 0; i < tmpWordsS2.length; i++) {
		if (stopWords[tmpWordsS2[i]] || tmpWordsS2[i].length <= 2) continue;
		wordsS2.push(tmpWordsS2[i]);
	}
	if (wordsS1.length == 0 || wordsS2.length == 0) return false;

	a = wordsS1.join(' ');
	b = wordsS2.join(' ');

    //var valuePhrase = levenshtein(a, b);

    var valueLength = Math.abs(a.length - b.length);

    var wb = 0;
    var se = false;
    var td = 0;
    var valueWords = 0;
    for (var i = 0; i < wordsS1.length; i++) {
        wb = b.length;
        se = $.soundEx(wordsS1[i]);
        for (var j = 0; j < wordsS2.length; j++) {
            td = $.levenshtein(wordsS1[i], wordsS2[j]);
            if (td < wb) wb = td;
            if (td == 0) break;

            if (se == $.soundEx(wordsS2[j])) {
                wb = 0;
                break;
            }
        }
        valueWords += wb;
    }

    //valuePhrase *= LEV_PHRASE_WEIGHT;
    /*return (Math.min(valuePhrase, valueWords) * MIN_WEIGHT) +
           (Math.max(valuePhrase, valueWords) * MAX_WEIGHT) +
           (valueLength * LEV_LENGTH_WEIGHT);
    */
    return (valueWords * (params['weight_words'] != undefined ? params['weight_words'] : 1.0)) + (valueLength * (params['weight_length'] != undefined ? params['weight_length'] : 0.3));
};

/*** base 64 ***/
$.base64_PADCHAR = '=';
$.base64_ALPHA = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

$.base64_makeDOMException = function() {
    // sadly in FF,Safari,Chrome you can't make a DOMException
    var e, tmp;

    try {
        return new DOMException(DOMException.INVALID_CHARACTER_ERR);
    } catch (tmp) {
        // not available, just passback a duck-typed equiv
        // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Error
        // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Error/prototype
        var ex = new Error("DOM Exception 5");

        // ex.number and ex.description is IE-specific.
        ex.code = ex.number = 5;
        ex.name = ex.description = "INVALID_CHARACTER_ERR";

        // Safari/Chrome output format
        ex.toString = function() { return 'Error: ' + ex.name + ': ' + ex.message; };
        return ex;
    }
}

$.base64_getbyte64 = function(s,i) {
    // This is oddly fast, except on Chrome/V8.
    //  Minimal or no improvement in performance by using a
    //   object with properties mapping chars to value (eg. 'A': 0)
    var idx = $.base64_ALPHA.indexOf(s.charAt(i));
    if (idx === -1) {
        throw $.base64_makeDOMException();
    }
    return idx;
}

$.base64_decode = function(s) {
	if (window.atob) return window.atob(s);

    // convert to string
    s = '' + s;
    var getbyte64 = $.base64_getbyte64;
    var pads, i, b10;
    var imax = s.length
    if (imax === 0) {
        return s;
    }

    if (imax % 4 !== 0) {
        throw $.base64_makeDOMException();
    }

    pads = 0
    if (s.charAt(imax - 1) === $.base64_PADCHAR) {
        pads = 1;
        if (s.charAt(imax - 2) === $.base64_PADCHAR) {
            pads = 2;
        }
        // either way, we want to ignore this last block
        imax -= 4;
    }

    var x = [];
    for (i = 0; i < imax; i += 4) {
        b10 = (getbyte64(s,i) << 18) | (getbyte64(s,i+1) << 12) |
            (getbyte64(s,i+2) << 6) | getbyte64(s,i+3);
        x.push(String.fromCharCode(b10 >> 16, (b10 >> 8) & 0xff, b10 & 0xff));
    }

    switch (pads) {
    case 1:
        b10 = (getbyte64(s,i) << 18) | (getbyte64(s,i+1) << 12) | (getbyte64(s,i+2) << 6);
        x.push(String.fromCharCode(b10 >> 16, (b10 >> 8) & 0xff));
        break;
    case 2:
        b10 = (getbyte64(s,i) << 18) | (getbyte64(s,i+1) << 12);
        x.push(String.fromCharCode(b10 >> 16));
        break;
    }
    return x.join('');
}

$.base64_getbyte = function(s,i) {
    var x = s.charCodeAt(i);
    if (x > 255) {
        throw $.base64_makeDOMException();
    }
    return x;
}

$.base64_encode = function(s) {
	if (window.btoa) return window.btoa(s);

    if (arguments.length !== 1) {
        throw new SyntaxError("Not enough arguments");
    }
    var padchar = $.base64_PADCHAR;
    var alpha   = $.base64_ALPHA;
    var getbyte = $.base64_getbyte;

    var i, b10;
    var x = [];

    // convert to string
    s = '' + s;

    var imax = s.length - s.length % 3;

    if (s.length === 0) {
        return s;
    }
    for (i = 0; i < imax; i += 3) {
        b10 = (getbyte(s,i) << 16) | (getbyte(s,i+1) << 8) | getbyte(s,i+2);
        x.push(alpha.charAt(b10 >> 18));
        x.push(alpha.charAt((b10 >> 12) & 0x3F));
        x.push(alpha.charAt((b10 >> 6) & 0x3f));
        x.push(alpha.charAt(b10 & 0x3f));
    }
    switch (s.length - imax) {
    case 1:
        b10 = getbyte(s,i) << 16;
        x.push(alpha.charAt(b10 >> 18) + alpha.charAt((b10 >> 12) & 0x3F) +
               padchar + padchar);
        break;
    case 2:
        b10 = (getbyte(s,i) << 16) | (getbyte(s,i+1) << 8);
        x.push(alpha.charAt(b10 >> 18) + alpha.charAt((b10 >> 12) & 0x3F) +
               alpha.charAt((b10 >> 6) & 0x3f) + padchar);
        break;
    }
    return x.join('');
}

/********** SEARCH REFRESH METHODS *********/
dhtmlXGridObject.prototype.CF_refreshSpecificRecordIds = function(idsRequested) {
    if (!this.CF_searchLoadDataForIdsFunc) return;

    CF_beginProgress('Loading records');

    var prevFilters = false;
    if (this.isTreeGrid()) {
    	prevFilters = this.CF_getFilters();
    	this.CF_clearFilters();
    }

	var meth = this.attachEvent('CF_onRefreshLoadComplete', function () {
		this.CF_reevaluateGroupRows(idsRequested);
		if (this.isTreeGrid()) {
			this.CF_applyFilters(prevFilters);
		}
		this.callEvent("onFilterEnd", []); // to get the stats to reevaluate
		this.detachEvent(meth);
	});

    this.CF_errors = [];
    this.CF_tmp_dataSequence = idsRequested;
    this.CF_numRecordsProcessed = 0;
    this.CF_updateLoadProgress(this.CF_tmp_dataSequence.length);
    this.CF_lastIndex = 0;
    this.CF_beginConcurrentRefresh();
}
dhtmlXGridObject.prototype.CF_beginConcurrentRefresh = function() {
    // limit concurrency to 6 - that's what most new browsers support by default
    for (var i = 0; i < 6; i++) {
        if (!this.CF_loadRefreshResults()) break;
    }
}
dhtmlXGridObject.prototype.CF_loadRefreshResults = function() {
  lastIdBatch = [];
  var readTill = this.CF_tmp_dataSequence.length < (this.CF_lastIndex + LOAD_PAGE_SIZE) ? this.CF_tmp_dataSequence.length : this.CF_lastIndex + LOAD_PAGE_SIZE;
  for (var i = this.CF_lastIndex; i < readTill; i++) {
    lastIdBatch.push(this.CF_tmp_dataSequence[i]);
  }
  this.CF_lastIndex = readTill;

  var g = this;
  if (lastIdBatch.length > 0) g.CF_searchLoadDataForIdsFunc(lastIdBatch, function(res, event) { g.CF_handleRefreshLoadResults(res, event); }, {escape: false});
  return lastIdBatch.length > 0;
}
dhtmlXGridObject.prototype.CF_handleRefreshLoadResults = function(result, event) {
  // invoke the next one
  this.CF_loadRefreshResults();

  var req = getIDBatchForEvent(event);
  if (event.status == true) {
    eval('result = ' + result);

    var rec, exists, idd;
    for (var i = 0; i < result.length; i++) {
        idd = result[i].Id;
        exists = this.CF_dataById[idd];
        rec = this.CF_getSFToGridConvertedRec(idd, result[i]);
        rec = rec['data'];

        // go through the row in update all fields and mark it not dirty
        if (exists) {
            var curRec = this.CF_getByIdFromBackingData(idd);
            // update the grid
            for (var j = 0; j < rec.length; j++) {
                this.CF_setValueInCellRec(curRec, j, rec[j]);
                this.CF_setWasChanged(idd, j, false);
            }
        } else {
            // add it to the grid
            if (this.CF_isInGroupMode()) {
            	// make sure group exists first
				var rec_grp_id = '_grp';
				var prev_rec_grp_id = false;
				var grp_vals = [];
	
				for (var j = 0; j < this.CF_groupFields.length; j++) {
					rec_grp_id += '_';
					var ind = this.CF_groupFields[j];
	            	if (this.CF_fieldDef[ind]['related']) {
	            		rec_grp_id += this.CF_getUserData(idd, this.CF_fieldDef[ind]['field']);
	                } else {
	                	rec_grp_id += rec[ind];
	                }
	                grp_vals.push(rec[ind]);
	                if (!this.CF_hasId(rec_grp_id)) {
	                	// create this one
	                	var d = [];
	                	for (var k = 0; k <= ind; k++) {
	                		d.push('');
	                	}
	                	for (var k = 0; k <= j; k++) {
	                		d[this.CF_groupFields[k]] = grp_vals[k];
	                	}
	                	this.CF_addRow(rec_grp_id, d, prev_rec_grp_id)
	                }
	                prev_rec_grp_id = rec_grp_id;
				}
				this.CF_addRow(idd, rec, rec_grp_id);
            } else {
            	this.CF_addRow(idd, rec);
            }
            this.CF_dataSequence.unshift(idd);
        }
    }
    this.CF_numRecordsProcessed += result.length;
  } else {
    // an anomoly occurred - find more info from this request and set all pending accounts in that list with this
    this.CF_numRecordsProcessed += req.length;
    this.CF_errors.push(event.message);
  }
  this.CF_handleRefreshLoadComplete();
}
dhtmlXGridObject.prototype.CF_handleRefreshLoadComplete = function() {
    this.CF_updateLoadProgress(this.CF_tmp_dataSequence.length);
    if (this.CF_numRecordsProcessed == this.CF_tmp_dataSequence.length) {
    	this.callEvent('CF_onRefreshLoadComplete', []);
        CF_endProgress();
        if (this.CF_errors.length == 0) {
            // nothing to do
        } else {
            alert('An error occurred: ' + this.CF_errors[0]);
        }
    }
}



/********** SEARCH / LOADING METHODS *********/
dhtmlXGridObject.prototype.CF_beginSearch = function() {
  lastIdBatch = [];

  CF_beginProgress('Finding records');

  if (this.CF_dataById === false) {
      this.CF_dataById = {};
      var g = this;
      this.CF_resetRequeryTimer();
      this.CF_searchGetIdsFunc(LOAD_PAGE_SIZE, function(res, event) { g.CF_searchResultsHandler(res, event); }, {escape: false});
  } else {
      // we already have records from before - reload data for those same IDs
      for (var i = 0; i < this.CF_dataSequence.length; i++) {
        this.CF_dataById[this.CF_dataSequence[i]] = i;
      }
      if (this.CF_dataSequence.length == 0) {
        // we're already done
        this.CF_handleLoadComplete();
      } else {
        this.CF_updateLoadProgress();
        this.CF_beginConcurrentSearch();
      }
  }
}

dhtmlXGridObject.prototype.CF_beginConcurrentSearch = function() {
    // limit concurrency to 6 - that's what most new browsers support by default
    for (var i = 0; i < 6; i++) {
        if (!this.CF_loadResults()) break;
    }
}
dhtmlXGridObject.prototype.CF_searchResultsHandler = function(res, event) {
  if (event.status) {
    var maxNumRecs = res['limit'];
    var tmp_dataSequence = res['ids'];
    eval('tmp_dataSequence = ' + tmp_dataSequence);
    this.CF_dataSequence = tmp_dataSequence;
    for (var i = 0; i < this.CF_dataSequence.length; i++) {
        this.CF_dataById[this.CF_dataSequence[i]] = i;
    }
    // we might have had results, load them first if we do
    this.CF_updateLoadProgress();

    if (res['results']) {
        eval('var recs = ' + res['results']);
        this.CF_lastIndex = recs.length;
        this.CF_loadRecs(recs);
        this.CF_handleLoadComplete();
    }

    this.CF_lastRequeryTs = res['ts'];
    this.CF_beginConcurrentSearch();
  } else {
    alert(event.message);
    CF_endProgress();
  }
}
dhtmlXGridObject.prototype.CF_loadRecs = function(result, idsRequested) {
    var idsFetched = {};
    for (var i = 0; i < result.length; i++) {
        idsFetched[result[i].Id] = 1;
        this.CF_dataById[result[i].Id] = result[i];
    }
    if (idsRequested) {
        for (var i = 0; i < idsRequested.length; i++) {
            if (idsFetched[idsRequested[i]]) continue;
            // this one we didn't get back, get rid of it from our list of IDs possible
            delete this.CF_dataById[idsRequested[i]];
        }
    }
    // we increase the result set by the length of the data set requested since we may get less records back
    // permissions or record is no longer there since the time we asked for it, etc
    var len = idsRequested ? idsRequested.length : result.length;
    this.CF_numRecordsProcessed += len;
}
dhtmlXGridObject.prototype.CF_getDataValue = function(fieldIndex, rec) {
    var x = '';
    if (this.CF_fieldDef[fieldIndex].value_func) {
        x = this.CF_fieldDef[fieldIndex].value_func(rec, this.CF_fieldDef[fieldIndex]);
    } else {
        x = rec[this.CF_fieldDef[fieldIndex].field];
    }
    if (x == null) x = '';
    var a = this.CF_fieldDef[fieldIndex];
    if (a['type'] == 'chro' || a['type'] == 'ch' || a['type'] == 'chvf') {
    	x = $.strToBool(x) ? '1' : '0';
    } else if (a['sort'] == 'date') {
        if (x != '') {
            var d;
            if ($.isNumeric(x)) {
                d = new Date(x);
            } else {
                d = new Date();
                try {
                    d.setISO8601(x);
                } catch(err) {
                    d = false;
                }
                if (!d) {
                    // error occurred - try one last time to simply pass x to d
                    d = new Date(x);
                }
            }
            if (isNaN(d.getTime())) x = '';

            // make sure x is still valid
            if (x != '') {
            	$.formatDate
                if (a['soapType'] == 'DATETIME') {
                	x = $.formatDateTime(d);
                } else {
                	x = $.formatDate(d);
                }
            }
        }
    }
    return x;
}
dhtmlXGridObject.prototype.CF_prepareRecForDisplay = function(i) {
    var idd = this.CF_dataSequence[i];
    var row = this.CF_dataById[idd];
    return this.CF_getSFToGridConvertedRec(idd, row);
}
dhtmlXGridObject.prototype.CF_getSFToGridConvertedRec = function(idd, row) {
    var a = [];
    var rec = {'id': idd};
    if (!row.length) {
        for (var j = 0; j < this.CF_fieldDef.length; j++) {
            var val = this.CF_getDataValue(j, row);
            if (this.CF_fieldDef[j]['related']) {
                // get the related info
                var f = this.CF_fieldDef[j]['related_field'].split('.');
                var x = row[f[0]];
                if (x) x = x[f[1]];
                if (x == null) x = '';
                a.push(x);

                if (!this.CF_relatedById[idd]) this.CF_relatedById[idd] = {};
                this.CF_relatedById[idd][this.CF_fieldDef[j]['field']] = val;
                this.setUserData(idd, this.CF_fieldDef[j]['field'], val);
            }else {
                a.push(val);
            }
        }
    } else {
        // already in rendered view
        a = row;
    }

    // update the dataById with the display values now that we have them - create a copy since the orig goes to
    // the grid buffer
    this.CF_dataById[idd] = a.slice(0);

    rec['data'] = a;

    return rec;
}
dhtmlXGridObject.prototype.CF_displayData = function() {
	var disp = [];

   	// if no grouping, then go default route
   	if (!this.CF_isInGroupMode()) {
		for (var i = 0; i < this.CF_dataSequence.length; i++) {
		    disp.push(this.CF_prepareRecForDisplay(i));
		}
   	} else {
	    var seenRecs = {};
	    for (var i = 0; i < this.CF_dataSequence.length; i++) {
	    	var rec = this.CF_prepareRecForDisplay(i);

			var rec_grp_id = '_grp';
			var prev_rec_grp_id = '';
			var grp_vals = [];
			var dd = false;
			for (var j = 0; j < this.CF_groupFields.length; j++) {
				rec_grp_id += '_';
				var ind = this.CF_groupFields[j];
            	if (this.CF_fieldDef[ind]['related']) {
            		rec_grp_id += this.CF_getUserData(rec.id, this.CF_fieldDef[ind]['field']);
                } else {
                	rec_grp_id += rec['data'][ind];
                }
                grp_vals.push(rec['data'][ind]);
                dd = seenRecs[rec_grp_id];
                if (!dd) {
                	var d = [];
                	for (var k = 0; k <= ind; k++) {
                		d.push('');
                	}
                	for (var k = 0; k <= j; k++) {
                		d[this.CF_groupFields[k]] = grp_vals[k];
                	}
                	dd = {rows: [], id: rec_grp_id, data: d};
                	seenRecs[rec_grp_id] = dd;
                	if (prev_rec_grp_id == '') {
                		// first time seeing this one
                		disp.push(dd);
                	} else {
                		seenRecs[prev_rec_grp_id]['rows'].push(dd);
                	}
                }
                prev_rec_grp_id = rec_grp_id;
			}

			dd['rows'].push(rec);
	    }
   	}
   	this.parse({'rows':disp}, "json");
	this.CF_loadComplete = true;
	this.callEvent('CF_onLoadComplete',[]);
	CF_endProgress();
}
dhtmlXGridObject.prototype.CF_handleLoadComplete = function() {
    this.CF_updateLoadProgress();
    if (this.CF_numRecordsProcessed == this.CF_dataSequence.length) {
        if (this.CF_errors.length == 0) {
            $('#CF_progressCustomMessage').text('Preparing view');

            // go through the dataById array since the recs that couldn't be loaded need to be removed from the datasequence list
            for (var i = this.CF_dataSequence.length - 1; i >= 0; i--) {
                if (this.CF_dataById[this.CF_dataSequence[i]]) continue;
                this.CF_dataSequence.splice(i, 1);
            }

            // for most things this is ok, but if the grid was just rendered and we want to display, we give it some time
            // so it can also do its own timeout things like splits, etc
            (function(grid) {
                setTimeout(function() { grid.CF_displayData(); }, 10);
            })(this);
        } else {
            alert('An error occurred: ' + this.CF_errors[0]);
            CF_endProgress();
        }
    }
}
dhtmlXGridObject.prototype.CF_handleLoadResults = function(result, event) {
  // invoke the next one
  this.CF_loadResults();

  var req = getIDBatchForEvent(event);
  if (event.status == true) {
    eval('result = ' + result);
    this.CF_loadRecs(result, req);
  } else {
    // an anomoly occurred - find more info from this request and set all pending accounts in that list with this
    this.CF_numRecordsProcessed += req.length;
    this.CF_errors.push(event.message);
  }
  this.CF_handleLoadComplete();
}
dhtmlXGridObject.prototype.CF_loadResults = function() {
  lastIdBatch = [];
  var readTill = this.CF_dataSequence.length < (this.CF_lastIndex + LOAD_PAGE_SIZE) ? this.CF_dataSequence.length : this.CF_lastIndex + LOAD_PAGE_SIZE;
  for (var i = this.CF_lastIndex; i < readTill; i++) {
    lastIdBatch.push(this.CF_dataSequence[i]);
  }
  this.CF_lastIndex = readTill;

  var g = this;
  if (lastIdBatch.length > 0) g.CF_searchLoadDataForIdsFunc(lastIdBatch, function(res, event) { g.CF_handleLoadResults(res, event); }, {escape: false});
  return lastIdBatch.length > 0;
}
/************* END SEARCH / LOADING METHODS *****************/

dhtmlXGridObject.prototype.CF_saveChanges = function() {
    if (this.CF_dataSequence.length == 0) return;

	this.CF_prevFilters = this.CF_getFilters();
	this.CF_clearFilters(); // clear the filter so when we delete rows, the user can see what was deleted

	this.CF_startFastOperations();

    this.CF_idsToDel = {};
    this.CF_lastIndex = 0;
    lastIdBatch = [];
    this.CF_numRecordsProcessed = 0;
    this.CF_errors = [];
    this.CF_tmp_dataSequence = []; // keeps track of successful ones to merge later
    CF_beginProgress('Saving');
    this.CF_updateLoadProgress();

    for (var i = 0; i < 6; i++) {
        if (!this.CF_sendBatchToSave()) break;
    }
}
dhtmlXGridObject.prototype.CF_isGridDirty = function() {
    for (var i = 0; i < this.CF_dataSequence.length; i++) {
    	if (this.CF_isRecordDirty(this.CF_dataSequence[i])) return true;
    }
    return false;
}
dhtmlXGridObject.prototype.CF_isRecordDirty = function(idd) {
    return $.isTemporaryId(idd) || !$.isEmptyObject(this.CF_getChangesForRecord(idd));
}
dhtmlXGridObject.prototype.CF_getChangesForRecord = function(idd) {
    var rec = this.CF_getByIdFromBackingData(idd);

    var changes = {};
    if (this.CF_getUserData(rec.idd, 'deleted')) {
        // this one is deleted, send to the server
        changes['IsDeleted'] = 1;
    } else {
    	var isTemp = $.isTemporaryId(rec.idd);
    	if (isTemp || this.CF_getUserData(rec.idd, 'CF_dirty')) {
	        for (var j = 0; j < this.CF_fieldDef.length; j++) {
	            if (this.CF_fieldDef[j]['skip_track_changes']) continue;
	
	            var changed = this.CF_sendAllDataForSave; // if send all changes, set to true
	            var prevVal = '';
	            var newVal = false;
	            if (this.CF_fieldDef[j]['related']) {
	                // compare value from user defined field
	                newVal = this.CF_getUserData(rec.idd, this.CF_fieldDef[j]['field']);
	            } else {
	                newVal = this.CF_getValueFromCellRec(rec, j);
	            }

				if (!changed) {
		            if ($.isTemporaryId(rec.idd)) {
		               prevVal = '';

		               // if checkbox and not checked, set it back to empty so we don't trigger a save
		               if ((this.CF_fieldDef[j]['type'] == 'ch' || this.CF_fieldDef[j]['type'] == 'chro') && newVal == '0') {
		               		newVal = null;
		               }

		               // if the new val is null or undefined, then it really hasn't been specified, no need to send
		               if (newVal == undefined || newVal == null) prevVal = newVal;
		            } else {
		               if (this.CF_fieldDef[j]['related']) {
		                   prevVal = this.CF_relatedById[rec.idd][this.CF_fieldDef[j]['field']];
		               } else {
		                   prevVal = this.CF_dataById[rec.idd][j];
		               }
		            }
			        // to make it easier to compare '0' with 0
			        if ((typeof newVal) == 'number') {
			        	changed = newVal != parseFloat(prevVal);
			        } else if ((typeof prevVal) == 'number') {
			        	changed = prevVal != parseFloat(newVal );
			        } else {
			            changed = newVal != prevVal;
			        }
		        }
	            if (changed) {
	            	if (newVal && this.CF_fieldDef[j].soapType == 'DATE') {
	            		newVal = $.formatDate($.parseDate(newVal), 'mm/dd/yy');
	            	} else if (newVal && this.CF_fieldDef[j].soapType == 'DATETIME') {
	            		newVal = $.formatDateTime($.parseDateTime(newVal), 'mm/dd/yy');
	            	}
	                changes[this.CF_fieldDef[j]['field']] = newVal;
	            }
	        }
	    }
    }
    return changes;
}
dhtmlXGridObject.prototype.CF_sendBatchToSave = function() {
    // check chunk of SAVE_PAGE_SIZE rows at a time and send the data
    var recsToSend = {};
    var changes = false;
    var rec = false;
    lastIdBatch = [];

    // no more left 
    if (this.CF_lastIndex == this.CF_dataSequence.length) {
        return false;
    }

    var readTill = this.CF_dataSequence.length < (this.CF_lastIndex + SAVE_PAGE_SIZE) ? this.CF_dataSequence.length : this.CF_lastIndex + SAVE_PAGE_SIZE;

    // get it from the rowbuffer or the fakebuffer
    for (var i = this.CF_lastIndex; i < readTill; i++) {
        rec = this.CF_getByIdFromBackingData(this.CF_dataSequence[i]);
        changes = this.CF_getChangesForRecord(rec.idd);
        if (!$.isEmptyObject(changes)) {
            // queue to send
            lastIdBatch.push(rec.idd);
            recsToSend[rec.idd] = changes;
        } else {
            this.CF_numRecordsProcessed++;
            if ($.isTemporaryId(rec.idd)) {
                // temporary (new) record but not being sent...means user didn't select anything
                this.CF_setValueInCellRec(rec, this.CF_indexByField['__error'], 'Please specify one or more values to save this record.');
                this.CF_errors.push(1);
            } else {
                // clear out the error column
                this.CF_setValueInCellRec(rec, this.CF_indexByField['__error'], '');
            }
        }
    }

    this.CF_lastIndex = readTill;
    if (!$.isEmptyObject(recsToSend)) {
        var g = this;
        g.CF_saveRecsFunc(recsToSend, function(res, event) { g.CF_saveChangesHandler(res, event); }, {escape: false});
    } else {
        if (!this.CF_handleBatchSaveComplete()) {
            // start another one in a timeout to give some breathing room
            (function(grid) {
                setTimeout(function() { grid.CF_sendBatchToSave(); }, 10);
            })(this);
        }
    }
    return this.CF_lastIndex < this.CF_dataSequence.length;
}
dhtmlXGridObject.prototype.CF_deleteRowCommit = function(idd) {
     this.CF_deleteRow(idd);

     // clear from dataById and datasequence
     delete this.CF_dataById[idd];
     delete this.CF_relatedById[idd];
     this.CF_idsToDel[idd] = '1';
}
dhtmlXGridObject.prototype.CF_getTotalRecordCount = function() {
	if (this._f_rowsBuffer) {
		return this._f_rowsBuffer.length;
	}
	return this.rowsBuffer.length;
}
dhtmlXGridObject.prototype.CF_saveChangesHandler = function(res, event) {
  // start the next request
  this.CF_sendBatchToSave();

  var saveFlagColIndex = this.CF_indexByField['__error'];
  var rec, cellObj;
  if (event.status) {
    var newIds = {};
    for (var idd in res['success']) {
        this.CF_numRecordsProcessed++;
        if (this.CF_getUserData(idd, 'deleted')) {
            // delete record from grid (also deletes user data)
            this.CF_deleteRowCommit(idd);
        } else {
            // if new record, update id in the grid and dataSequence and create in dataById
            var isNewRec = false;
            if (this.CF_getUserData(idd, 'CF_dirty')) {
            	this.setUserData(idd, 'CF_dirty', false);
            }
            if ($.isTemporaryId(idd)) {
                var newId = res['success'][idd][0];
                newIds[idd] = newId;
                this.changeRowId(idd, newId);
                idd = newId;
                isNewRec = true;
                this.CF_dataById[newId] = []; // it will get updated in the for loop below
                this.CF_relatedById[newId] = {};
            }

            rec = this.CF_getByIdFromBackingData(idd);

            for (var j = 0; j < this.CF_fieldDef.length; j++) {
                if (this.CF_fieldDef[j]['skip_track_changes']) continue;

                // set value in the grid AND in dataById so we don't count it as different next time
                var val = '';
                var prevVal = '';
                if (this.CF_fieldDef[j]['related']) {
                   val = this.CF_getUserData(idd, this.CF_fieldDef[j]['field']);
                   prevVal = this.CF_relatedById[rec.idd][this.CF_fieldDef[j]['field']];
                } else {
                   val = this.CF_getRowValueInCellRec(rec, j);
                   prevVal = this.CF_dataById[rec.idd][j];
                }

                if ((isNewRec && val != '') || (val != prevVal)) {
                    if (this.CF_fieldDef[j]['related']) {
                       this.CF_relatedById[idd][this.CF_fieldDef[j]['field']] = val;
                       this.CF_dataById[idd][j] = this.CF_getRowValueInCellRec(rec, j);
                    } else {
                       this.CF_dataById[idd][j] = val;
                    }
                    this.CF_setWasChanged(idd, j, false);
                }
            }
            this.CF_setValueInCellRec(rec, saveFlagColIndex, '');
            this.CF_tmp_dataSequence.push(idd);
        }
    }
    if (!$.isEmptyObject(newIds)) {
        for (var i = this.CF_dataSequence.length - 1; i >= 0; i--) {
            if (newIds[this.CF_dataSequence[i]]) {
                this.CF_dataSequence[i] = newIds[this.CF_dataSequence[i]];
            }
        }
    }

    var hasErrors = false;
    for (var idd in res['errors']) {
        this.CF_numRecordsProcessed++;
        hasErrors = true;
        rec = this.CF_getByIdFromBackingData(idd);
        this.CF_setValueInCellRec(rec, saveFlagColIndex, res['errors'][idd][0]);
        if (this.CF_isRowRendered(idd)) {
            for (var j = 0; j < this.CF_fieldDef.length; j++) {
                cellObj = this.cells(idd, j);
                if ($(cellObj.cell).hasClass('changed_flag')) {
                    this.CF_addClassToCell(cellObj, idd, j, 'errored_flag');
                }
            }
        }
    }
    if (hasErrors) this.CF_errors.push(1);
  } else {
    // an anomoly occurred - find more info from this request and set all pending accounts in that list with this
    var idds = getIDBatchForEvent(event);
    for (var i = 0; i < idds.length; i++) {
        this.CF_numRecordsProcessed++;
        var idd = idds[i];
        rec = this.CF_getByIdFromBackingData(idd);
        this.CF_setValueInCellRec(rec, saveFlagColIndex, event.message);
        if (this.CF_isRowRendered(idd)) {
            for (var j = 0; j < this.CF_fieldDef.length; j++) {
                cellObj = this.cells(idd, j);
                if ($(cellObj.cell).hasClass('changed_flag')) {
                    this.CF_addClassToCell(cellObj, idd, j, 'errored_flag');
                }
            }
        }
    }
    this.CF_errors.push(1);
  }
  this.CF_handleBatchSaveComplete();
}
dhtmlXGridObject.prototype.CF_handleBatchSaveComplete = function() {
  this.CF_updateLoadProgress();
  if (this.CF_numRecordsProcessed == this.CF_dataSequence.length) {
  	  this.CF_stopFastOperations();
      this.CF_flushIdsToDel();
      var hasErrors = this.CF_errors.length > 0;

      var g = this;
      CF_doWhenIdle(function() {
          CF_beginProgress();
          if (g.CF_tmp_dataSequence.length > 0) {
                // need to load successful
                g.CF_refreshSpecificRecordIds(g.CF_tmp_dataSequence);
          }
          CF_doWhenIdle(function() {
              CF_beginProgress();
              if (hasErrors) {
                  g.CF_applyFilters({__error: {value: '1'}});
                  alert('Save completed with errors.  Only records that failed are displayed for review.  To view all records, click the Clear Filters icon.');
              } else {
              	  // reapply filters - no errors - helpful because we may have visible checked rows that we need to reshow
              	  g.CF_applyFilters(g.CF_prevFilters);
              	  delete g.CF_prevFilters;
              }
              g.callEvent('CF_onSaveComplete', [!hasErrors]);
              CF_endProgress();
          });
          CF_endProgress();
      });

      CF_endProgress();
      return true;
  }
  return false;
}

/*** MASS FUNCTION TO GRIDS ****/
dhtmlXGridObject.prototype.CF_submitBatchOperation = function(sel, func, page_size, progress_message, thread_count) {
    if (!sel || sel.length == 0) return;

    this.CF_bachOperationRecs = sel;
    this.CF_lastIndex = 0;
    this.CF_batchOperationPageSize = page_size || 5;
    this.CF_batchOperationFunc = func;
    lastIdBatch = [];
    this.CF_numRecordsProcessed = 0;
    this.CF_errors = [];
    CF_beginProgress(progress_message || 'Processing...');
    this.CF_updateLoadProgress(this.CF_bachOperationRecs.length);
    thread_count = thread_count || 6;

    for (var i = 0; i < thread_count; i++) {
        if (!this.CF_sendForBatchOperation()) break;
    }
}
dhtmlXGridObject.prototype.CF_sendForBatchOperation = function() {
    // check chunk of SAVE_PAGE_SIZE rows at a time and send the data
    var recsToSend = [];
    var changes = false;
    var rec = false;
    var cellObj = false;
    lastIdBatch = [];

    // no more left 
    if (this.CF_lastIndex == this.CF_bachOperationRecs.length) {
        return false;
    }

    var readTill = this.CF_bachOperationRecs.length < (this.CF_lastIndex + this.CF_batchOperationPageSize) ? this.CF_bachOperationRecs.length : this.CF_lastIndex + this.CF_batchOperationPageSize;

    // get it from the rowbuffer or the fakebuffer
    for (var i = this.CF_lastIndex; i < readTill; i++) {
        rec = this.CF_getBufferSequenceRec(this.CF_bachOperationRecs[i]);
        lastIdBatch.push(rec.idd);
        recsToSend.push(rec.idd);
    }

    this.CF_lastIndex = readTill;
    if (recsToSend.length > 0) {
        var g = this;
        this.CF_batchOperationFunc(recsToSend, function(res, event) { g.CF_batchResponseHandler(res, event); });
    } else {
        if (!this.CF_batchCompleteHandler()) {
            // start another one in a timeout to give some breathing room
            var g = this;
            (function(grid) {
                setTimeout(function() { g.CF_sendForBatchOperation(); }, 10);
            })(this);
        }
    }
    return this.CF_lastIndex < this.CF_bachOperationRecs.length;
}
dhtmlXGridObject.prototype.CF_batchResponseHandler = function(res, event) {
  // start the next request
  this.CF_sendForBatchOperation();

  var saveFlagColIndex = this.CF_indexByField['__error'];
  var rec;
  if (event.status) {
    var newIds = {};
    for (var idd in res['success']) {
        this.CF_numRecordsProcessed++;
        rec = this.CF_getByIdFromBackingData(idd);
        this.CF_setValueInCellRec(rec, saveFlagColIndex, '');
    }

    var hasErrors = false;
    for (var idd in res['errors']) {
        this.CF_numRecordsProcessed++;
        hasErrors = true;
        rec = this.CF_getByIdFromBackingData(idd);
        this.CF_setValueInCellRec(rec, saveFlagColIndex, res['errors'][idd][0]);
        if (this.CF_isRowRendered(idd)) {
            for (var j = 0; j < this.CF_fieldDef.length; j++) {
                cellObj = this.cells(idd, j);
                if ($(cellObj.cell).hasClass('changed_flag')) {
                    this.CF_addClassToCell(cellObj, idd, j, 'errored_flag');
                }
            }
        }
    }
    if (hasErrors) this.CF_errors.push(1);
  } else {
    // an anomoly occurred - find more info from this request and set all pending accounts in that list with this
    var idds = getIDBatchForEvent(event);
    for (var i = 0; i < idds.length; i++) {
        this.CF_numRecordsProcessed++;
        var idd = idds[i];
        rec = this.CF_getByIdFromBackingData(idd);
        this.CF_setValueInCellRec(rec, saveFlagColIndex, event.message);
        if (this.CF_isRowRendered(idd)) {
            for (var j = 0; j < this.CF_fieldDef.length; j++) {
                cellObj = this.cells(idd, j);
                if ($(cellObj.cell).hasClass('changed_flag')) {
                    this.CF_addClassToCell(cellObj, idd, j, 'errored_flag');
                }
            }
        }
    }
    this.CF_errors.push(1);
  }
  this.CF_batchCompleteHandler();
}
dhtmlXGridObject.prototype.CF_batchCompleteHandler = function() {
  this.CF_updateLoadProgress(this.CF_bachOperationRecs.length);
  if (this.CF_numRecordsProcessed == this.CF_bachOperationRecs.length) {
  	var hasErrors = this.CF_errors.length > 0;
  	var g = this; 
    CF_doWhenIdle(function() {
        CF_beginProgress();
        if (hasErrors) {
			g.sortRows(g.CF_indexByField['__error'], '', 'des', true);
          	alert('Processed with errors.');
        }
        g.callEvent('CF_onBatchComplete', [!hasErrors]);
        CF_endProgress();
    });
    CF_endProgress();
    return true;
  }
  return false;
}
</script>




<script>
/*** PUTTING IT ALL TOGETHER ***/
function CF_layoutManager() {
   var that = this;
   this.dhxLayout = false;
   this.resizeTimer = 0;
   this.bsub = 10;
   this.rsub = 15;
   this.layoutDiv = false;
   this.dhxLayout = false;
   this.eventHooks = {};
   this.minSize = {'h': 400};
   this.saveLayoutPreferences = true;
   this.prevResizeTriggerDims = {}; // dimensions that caused the layout to resize last time
   this.forceSize = {};

   this.initRootLayout = function(layoutDivId, layoutStyle) {
       this.layoutDiv = $('#' + layoutDivId);

       if (this.layoutDiv.attr('bsub') != undefined) this.bsub = this.layoutDiv.attr('bsub');
       if (this.layoutDiv.attr('rsub') != undefined) this.rsub = this.layoutDiv.attr('rsub');
       if (layoutStyle['bsub'] != undefined) this.bsub = layoutStyle['bsub'];
       if (layoutStyle['rsub'] != undefined) this.rsub = layoutStyle['rsub'];
       if (layoutStyle['minSize'] != undefined) this.minSize = layoutStyle['minSize'];

       this.resizeLayout();
       this.dhxLayout = new dhtmlXLayoutObject(layoutDivId, layoutStyle['tmpl']);

       var resizeFunc = function() {
           // any custom resize things we may have added
           that.dhxLayout.callEvent('CF_panelResized',[]);

           if (that.saveLayoutPreferences) {
               var w = [];
               var cl = [];
               for (var i = 97; ; i++) { // start at lowecase a
                   var c = that.dhxLayout.cells(String.fromCharCode(i));
                   if (!c) break;
                   if (isNaN(c.getWidth())) {
                   	try {
	                   	var cca = $(c).children(':first').get(0);
	                   	var ccb = $('div.dhxcont_global_content_area', cca).get(0);
	                   	if (parseInt(ccb.style.width) > 0) {
	                   		cca.style.width = ccb.style.width;
	                   		c.style.width = cca.style.width;
	                   	}
                   	} catch(e) {}
                   }
                   var xx = c.CF_getWidthHeight();
                   if (isNaN(xx['dim'])) continue; // happens if in a lazy load tab or something
                   w.push(xx['dim']);
                   cl.push(xx['collapsed'] ? true : false);
               }
               {!$RemoteAction.Configero_Framework.savePagePreferences}($.getPageBaseName(), w, cl, function(result, event) {});
           }
       };

       that.dhxLayout.attachEvent('onResizeFinish', resizeFunc);
       that.dhxLayout.attachEvent('onPanelResizeFinish', resizeFunc);
       that.dhxLayout.attachEvent('onExpand', resizeFunc);
       that.dhxLayout.attachEvent('onCollapse', resizeFunc);

       // add the resize hooks
        for (var a = 0; a < this.dhxLayout.tpl.childNodes[0].childNodes.length; a++) {
            for (var b = this.dhxLayout.tpl.childNodes[0].childNodes[a], c = 0; c < b.childNodes.length; c++) {
                var d = b.childNodes[c], e = this;
                if (!d._isSep) {
                    (function() {
                        var e = d;
                        var eObj = $(e);
                        d.CF_setWidthHeight = function(wh) {
                            if (Number(wh)) wh = {dim: wh};
                            if ($('.dhtmlxInfoButtonShowHide_hor', eObj).length > 0) {
                                e.setWidth(wh['dim']);
                            } else {
                                e.setHeight(wh['dim']);
                            }
                            if (wh['collapsed']) {
                                e.collapse();
                            }
                        };
                        d.CF_getWidthHeight = function() {
                            if ($('.dhtmlxInfoButtonShowHide_hor', eObj).length > 0) {
                                if (e.isCollapsed()) return {dim: e._savedW, collapsed: true};
                                return {dim: e.getWidth()};
                            } else {
                                if (e.isCollapsed()) return {dim: e._savedH, collapsed: true};
                                return {dim: e.getHeight()};
                            }
                        };
                        d.CF_hideLayoutCell = function() {
                            e.collapse();
                            $('.dhtmlxInfoButtonShowHide_hor', eObj).first().hide();
                            $('.dhtmlxInfoButtonShowHide_ver', eObj).first().hide();
                        };
                        d.CF_showLayoutCell = function() {
                            e.expand();
                            $('.dhtmlxInfoButtonShowHide_hor', eObj).first().show();
                            $('.dhtmlxInfoButtonShowHide_ver', eObj).first().show();
                        };
                    })();
                }
            }
        }
       this._attachCellsToLayout(this.dhxLayout, layoutStyle);
       $(window).resize(function() {
           that.resizeContainer();
       });
       this.triggerEvent('CF_layoutCreated');
       return this.dhxLayout;
   };
   this.setSaveLayoutPreferences = function(how) {
    this.saveLayoutPreferences = how;
   }
   this.setForceWidth = function(w) {
    this.forceSize['w'] = w;
   }
   this.setForceHeight = function(h) {
    this.forceSize['h'] = h;
   }
   this.attachEvent = function(name, func) {
        if (!this.eventHooks[name]) this.eventHooks[name] = []; 
        this.eventHooks[name].push(func);
    }
    this.triggerEvent = function(name, args) {
        if(this.eventHooks[name]) {
            for(var i=0;i<this.eventHooks[name].length;i++) {
                this.eventHooks[name][i](this, args);
            }
        }
    }
   this._attachCellsToLayout = function(layoutObj, layoutStyle) {
       if (layoutStyle['toolbar']) { this._attachToolbar(layoutObj, layoutStyle['toolbar']) };
       var cells = layoutStyle['cells'];
       if (cells) {
           for (var c in cells) {
              var k = cells[c];
              var cc = this._assignToVar(layoutObj.cells(c), k['var']);
              if (k['text']) cc.setText(k['text']);
              if (k['width']) cc.setWidth(k['width']);
              if (k['height']) cc.setHeight(k['height']);
              if (k['status']) {
                  var st = this._assignToVar(cc.attachStatusBar(), k['status']['var']);
                  if (k['status']['text']) st.setText(k['status']['text']);
              }
              if (k['content']) {
                  var typ = k['content']['type'];
                  if (typ == 'tabs') this._attachTabbar(cc, k['content']);
                  else if (typ == 'grid') this._attachGrid(cc, k['content']);
                  else if (typ == 'layout') this._attachLayout(cc, k['content']);
                  else if (typ == 'tree') this._attachTree(cc, k['content']);
                  else if (typ == 'text') cc.attachObject($('<div />').text(k['content']['text']).get(0));
                  else if (typ == 'html') cc.attachObject(k['content']['html']);
                  else if (typ == 'url') cc.attachURL(k['content']['url']);
              }
              if (k['toolbar']) this._attachToolbar(cc, k['toolbar']);
              if (layoutStyle['dims'] && layoutStyle['dims'][c] != undefined) {
                  cc.CF_setWidthHeight(layoutStyle['dims'][c]);
              }
              if (k['postInit']) k['postInit'](cc);
           }
       }
       if (layoutStyle['postInit']) layoutStyle['postInit'](layoutObj);
   };
   this._assignToVar = function(obj, v) {
       if (v) {
        window[v] = obj;
        obj.CF_var = v;
       }
       return obj;
   };
   this._rndstr = function(a) {
       for (var b = '', e = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', f = 0; f < a; f++) {
           b += e.charAt(Math.round(Math.random() * (e.length - 1)));
       }
       return b;
   };

   /******** GRID FUNCS *************/
   this._attachLayout = function(cc, content) {
      var layout = this._assignToVar(cc.attachLayout(content['layout']['tmpl']));
      this._attachCellsToLayout(layout, content['layout']);
   };
   this._attachGrid = function(cc, content) {
      var grid = this._assignToVar(cc.attachGrid(), content['var']);
      
      // in older versions, setSizes gets called even though there's nothing to resize, so we just wrap it with a try/catch
      grid.setSizes_override = grid.setSizes;
      grid.setSizes = function() {
        try {
            this.setSizes_override();
        } catch(e) {}
      }
      grid.CF_fieldDef = content['grid']['fields'];

	  if (content['grid']['enableGroups'] !== false) {
	      var groups = [];
	      for (var i = 0; i < grid.CF_fieldDef.length; i++) {
	      	if (grid.CF_fieldDef[i]['group']) {
				groups.push(i);
			}
	 	  }
	 	  if (groups.length > 0) {
	 	  	grid.CF_groupFields = groups;
	 	  }
	 	  grid.CF_allowGroups = true;
	  } else {
	  	for (var i = 0; i < grid.CF_fieldDef.length; i++) {
	  		if (grid.CF_fieldDef[i]['field'] == '__group') {
	  			grid.CF_fieldDef[i]['width'] = 0;
	  			grid.CF_fieldDef[i]['type'] = 'blank';
	  			break;
	  		}
	  	}
	  }


      grid.CF_indexByField = {};
      grid.load_func = content['grid']['load_func'];
      grid._sortCore = grid.CF_gridSortCore;
      grid.sortRows = grid.CF_gridSortRows;
      // no need to do this since setSizes gets called on after sort as well
      /*grid.attachEvent('onAfterSorting', function(b) {
		this.CF_refreshSortIcons();
      });
      */
      grid.attachEvent('CF_bulkEditComplete', function(inds, ids) {
      	if (this.CF_isInGroupMode()) {
      		var hasGroupField = false;
      		for (var i = 0; i < inds.length; i++) {
      			if (this.CF_isGroupedField(inds[i])) {
      				hasGroupField = true;
      				break;
      			}
      		}
      		if (hasGroupField) {
      			this.CF_reevaluateGroupRows(ids);
      		}
      	}
      	// call this method since it's one of the ones that forces the stat footer and grouping #s to update
      	this.callEvent("onFilterEnd", []);
      });
      grid.attachEvent('onSetSizes', function() {
      	this.CF_refreshSortIcons();
      });
      grid.attachEvent('onClearAll', function() {
      	this.CF_sortSequence = false;
      	this.CF_refreshSortIcons();
      });
      grid.attachEvent('CF_onLoadComplete', function() {
        grid.CF_beginRequeryTimer();
      });
      grid.attachEvent('onDhxCalendarCreated', function(cal, showTime) {
      	if (!showTime) {
	      	cal.hideTime();
      	}
    	cal.setWeekStartDay(7);
      	return true;
      });
      grid.attachEvent('onFilterEnd', function(filters) {
      	grid.CF_filterEnd(filters);
      });
      grid.attachEvent('onEditCell', function(stage, rid, cindex, new_value, old_value) {
        return grid.CF_editCellFunc(stage, rid, cindex, new_value, old_value);
      });
      
      // leave this false by default since navigation still gets allowed while lightbox / async loading may be active
      // if this needs to be active, explicitly select it
      //grid.enableKeyboardSupport(content['grid']['allowKeyboardSupport']);
      var oldDk = grid.doKey;
      grid.doKey = function(ev) {
      	if (!CF_isIdle()) return true;
      	return oldDk.apply(this, [ev]);
      }
      
      grid.CF_doLookup = function(q, callback) {
          // if we need to have our custom function for callbacks, then call it
          if (grid.CF_fieldDef[q.index]['lookup_func']) {
            grid.CF_fieldDef[q.index]['lookup_func'](grid, q, callback);
          } else {
            var related = grid.CF_fieldDef[q.index]['related'];
            if (related.indexOf(',') >= 0) {
                // contains multiple - go the safe route
                $.CF_doLookup(CF_NAMESPACE_PREFIX + 'Configero_LookupName?obj=' + escape(related), callback);
            } else {
                // go the template route
                $.CF_doLookup(CF_NAMESPACE_PREFIX + 'Configero_LookupNameTemplate?obj=' + escape(related), callback);
            }
          }
      }
      grid.CF_getAutoCompleteParams = function(str, index, idd) {
			var related = grid.CF_fieldDef[index]['related'];
      		var ret = {q: str, c: related};
	      	var lid = grid.CF_getUserData(idd, grid.CF_fieldDef[index].field);
	      	if (lid) {
	      		ret['idd'] = lid;
	      	}
	      	return ret;
      }
      
      grid.attachEvent('onCheck', function(rid, cindex, state) {
        return grid.CF_checkCellFunc(rid, cindex, state);
      });
      grid.setDateFormat(grid.CF_getDateFormat());
      grid.setSkin("dhx_skyblue");

      grid.enableResizing(grid.CF_collapseFieldDef('allowResize', 'true'));
      var headerLabels = grid.CF_collapseFieldDef('name').split(',');
      for (var i = 0; i < headerLabels.length; i++) {
      	if (grid.CF_fieldDef[i]['helpText']) {
      		headerLabels[i] += '{#tooltip}';
      	}
      }
      grid.setHeader(headerLabels.join(','));
      grid.setColSorting(grid.CF_collapseFieldDef('sort'));
      grid.setInitWidths(grid.CF_collapseFieldDef('width'));
      grid.setColAlign(grid.CF_collapseFieldDef('align'));
      grid.setColTypes(grid.CF_collapseFieldDef('type'));
      if (content['grid']['allowFilter']) grid.attachHeader(grid.CF_collapseFieldDef('filter'));
      grid.attachEvent('onRowCreated', function(rid, rObj, rXML) {
        return grid.CF_rowCreatedInGrid(rid, rObj, rXML); 
      });

      grid.enableEditTabOnly(1);
      if (navigator.userAgent.match(/iPad/i) != null) {
      	// turn on single click editing for ipad
	    grid.enableEditEvents(true);
      }
      grid.setImageSize(1, 1); // get rid of folder and leaf icon in tree

      var hasSummaryType = false;
      var summaryType = [];

      // figure out the decimal and comma separator
      var thousandsSeparator = $.localeThousandsSeparator();
      var decimalSeparator = $.localeDecimalSeparator();

      for (var i = 0; i < grid.CF_fieldDef.length; i++) {
        if (grid.CF_fieldDef[i]['type'] == 'corotxt_ro' || grid.CF_fieldDef[i]['type'] == 'corotxt' || grid.CF_fieldDef[i]['type'] == 'plvf') {
            // list box - get combobox and update source
            var cb = grid.getCombo(i);
            cb.put('','');
            if (grid.CF_fieldDef[i]['PicklistVals']) {
                for (var j = 0; j < grid.CF_fieldDef[i]['PicklistVals'].length; j++) {
                    cb.put(grid.CF_fieldDef[i]['PicklistVals'][j].value, grid.CF_fieldDef[i]['PicklistVals'][j].label);
                }
            }
        }
        if (grid.CF_fieldDef[i]['numberFormat']) {
            if (grid.CF_fieldDef[i]['numberFormat'] == 'currency') {
                grid.setNumberFormat('0,000.00', i, decimalSeparator, thousandsSeparator);
            } else {
                grid.setNumberFormat(grid.CF_fieldDef[i]['numberFormat'], i, decimalSeparator, thousandsSeparator);
            }
        }
        if (grid.CF_fieldDef[i]['split'] && ((i + 1) < grid.CF_fieldDef.length)) {
            grid.CF_splitAt = i;
            grid.splitAt(i + 1);
        }
        if (grid.CF_fieldDef[i]['field']) {
            grid.CF_indexByField[grid.CF_fieldDef[i]['field']] = i;
        }
        if (grid.CF_fieldDef[i]['summary']) {
            hasSummaryType = true;
        }
        summaryType.push((grid.CF_fieldDef[i]['summary'] ? grid.CF_fieldDef[i]['summary'] : ''));
      }

      if (hasSummaryType) {
            grid.attachFooter(summaryType, grid.CF_collapseFieldDefArr('summaryStyle', 'text-align:right;'));
      }
      if (content['grid']['allowBulkEdit']) {
          grid.CF_hasBulkEditEnabled = true;
          grid.CF_createBulkEditFooter();
      }

      // note - can't use groupBy with smart rendering on!!!
      grid.enableSmartRendering(true, 50);

      if (content['grid']['customGroupFormat']) {
        grid.customGroupFormat = content['grid']['customGroupFormat'](grid);
      }

      if (content['grid']['allowMultiSelect']) grid.selMultiRows = true;
      if (content['grid']['allowDragDrop']) grid.enableDragAndDrop = true;

		/*
      var menu = new dhtmlXMenuObject();
      menu.addNewSibling(null, "grid", "Grid Context");
      menu.addNewChild("grid", 0, "lookup_open", "Open in new window", false);
      menu.renderAsContextMenu();
      menu.attachEvent("onClick", function(mnuId, type) {
      	alert('Clicked');
      });
      grid.attachEvent("onBeforeContextMenu", function() { return true; });
      grid.enableContextMenu(menu);
      */

      if (content['grid']['preInit']) content['grid']['preInit'](grid);

      grid.init();

	  // add the class name of the field to the column header
      for (i = 0; i < grid.CF_fieldDef.length; i++) {
      	if (grid.CF_fieldDef[i]['field']) {
      		$('.hdrcell', $(grid.hdr.rows[1].cells[i])).addClass('hdr_' + grid.CF_fieldDef[i]['field']);
      		if (grid.CF_splitAt && i <= grid.CF_splitAt) $('.hdrcell', $(grid._fake.hdr.rows[1].cells[i])).addClass('hdr_' + grid.CF_fieldDef[i]['field']);
      	}
      	if (grid.CF_fieldDef[i]['type'] == 'lkupcombo') {
      		var cb = grid.getColumnCombo(i);
      		// might cause issues on cache - what if something was just saved and needs to be in the cache?
      		cb.enableFilteringMode(true, function(xa) {
      			return function(mask) {
      				return grid.CF_getAutoCompleteParams(mask, xa, grid.getSelectedId());
      			};
      		}(i),true);
      		cb.attachEvent('CF_VFLookup', function(cindex) {
      			return function() {
		            var lkupRid = grid.getSelectedId();
		            grid.CF_doLookup({index: cindex}, function(params) {
	    	            grid.CF_updateLookupValueInGrid(lkupRid, cindex, params['id'], params['text']);
	        	        if (grid.CF_isInGroupMode() && grid.CF_isGroupedField(cindex)) {
	            	    	grid.CF_reevaluateGroupRows([lkupRid]);
		                }
		                $('#CF_lookupDialog').dialog('close');
	    	        });
	            	return false;
	         	};
      		}(i));
      	}
	  }

      if (content['grid']['allowBulkEdit'] || content['grid']['enableMassChecks']) {
      	grid.setColWidth(grid.CF_indexByField['__selectall'], '30');
      }
      if (!content['grid']['hideErrors']) {
	      grid.setColWidth(grid.CF_indexByField['__error'], '30');
      }
      if (grid.CF_splitAt) {
        //grid.sync_headers = grid._fake.sync_headers = grid.CF_syncHeaders;
      	var oldFakeDk = grid._fake.doKey;
      	grid._fake.doKey = function(ev) {
      		if (!CF_isIdle()) return true;
      		return oldFakeDk.apply(this, [ev]);
      	}
      }

      if (content['grid']['allowBulkEdit']) grid.CF_activateBulkEditFields();
      grid.CF_resetGrid();

      if (content['grid']['toolbar']) this._attachToolbar(cc, content['grid']['toolbar'], grid, function() {
      	grid.editStop();
      	return true;
      });

      if (content['grid']['postInit']) content['grid']['postInit'](grid);

	  $(':input', $(grid.hdr)).mousedown(function() { grid.editStop(); });

      this.triggerEvent('CF_gridCreated', grid);

      return grid;
   };

   this._attachTree = function(cc, content) {
      var tree = this._assignToVar(cc.attachTree(), content['var']);
      tree.enableSmartXMLParsing(true);
      if (content['tree']['toolbar']) this._attachToolbar(cc, content['tree']['toolbar'], tree);
      if (content['tree']['postInit']) content['tree']['postInit'](tree);
      return tree;
   };

   this._attachToolbar = function(cc, content, onClickArgs, preclickFunc) {
   	  var defImgPath = '{!URLFOR($Resource.AppIcons, '/')}';
      //if (!content['icon_path']) content['icon_path'] = defImgPath;

      // bug fix - set everything but items because the array is processed in random order and the items sometimes get set before the icon_path
      var items = content['items'];
      delete content['items'];

      if (!content['onClick']) {
          var clickArr = {};
          for (var i = 0; i < items.length; i++) {
              if (items[i]['onClick']) {
                  clickArr[items[i]['id']] = items[i]['onClick'];
              }
          }
          content['onClick'] = function(d) {
              if (clickArr[d]) clickArr[d](onClickArgs);
          }
      }
      var onc = content['onClick'];
      if (preclickFunc) {
      	var onx = onc;
      	onc = function(d) {
      		if (preclickFunc(d)) {
      			onx(d);
      		}
      	}
      }
      delete content['onClick'];

      var tbs = this._assignToVar(cc.attachToolbar(content), content['var']);

      // do this again because attaching a toolbar to a layout object doesn't carry over the properties!
      tbs.attachEvent('onClick', onc);
      //tbs.setIconPath(content['icon_path']); // don't do this anymore since all URLs need to be absolute or all relative - can't mix and match
      tbs.setIconSize(content['icon_size'] || 32);

	  for (var i = 0; i < items.length; i++) {
	  	if (items[i].img) {
	  		if (items[i].img.beginsWith('/') || items[i].img.indexOf('://') >= 0) {
	  			// let it be
	  		} else {
	  			items[i].img = defImgPath + items[i].img;
	  		}
	  	}
	  }
      tbs.items(items);
      if (content['postInit']) content['postInit'](tbs);
      return tbs;
   };
   this._attachTabbar = function(cc, content) {
        var tabBar = this._assignToVar(cc.attachTabbar(), content['var']);
        tabBar.setHrefMode('ajax-html');
        tabBar.enableAutoReSize(true);

        // since the layout header disappears when adding a tabbar
        cc.showHeader();
        for (var i = 0; i < content['tabs'].length; i++) {
            var tm = content['tabs'][i];
            var tabName = tm['name'];
            if (!tabName) tabName = '_t' + i;
            var w = tm['width'];
            if (!w) w = '100px';
            tabBar.addTab(tabName, tm['title'], w);
            var tb = this._assignToVar(tabBar.cells(tabName), tm['var']);
            if (i == 0) tabBar.setTabActive(tabName);
            if (tm['content']) {
                var typ = tm['content']['type'];
                if (typ == 'text') {
                    tabBar.setContentHTML(tabName, $.escapeHTML(tm['content']['text']));
                } else if (typ == 'html') {
                    tabBar.setContent(tabName, tm['content']['html']);
                } else if (typ == 'layout') {
                    this._attachLayout(tb, tm['content']);
                } else if (typ == 'grid') {
                    this._attachGrid(tb, tm['content']);
                } else if (typ == 'tree') {
                    this._attachTree(tb, tm['content']);
                }
            }

            if (tm['toolbar']) this._attachToolbar(tb, tm['toolbar']);
            if (tm['postInit']) tm['postInit'](tb);
        }

	   tabBar.attachEvent('onSelect', function(dest, src) {;
	       var w = window[dest];
	       if (w) w.CF_onSelect();
	       return true;
	   });
	
	   // initialize the first one
	   if (window[tabBar.getActiveTab()]) window[tabBar.getActiveTab()].CF_onSelect();
	
        return tabBar;
   };
   this.resizeContainer = function(force) {
     clearTimeout(this.resizeTimer);
     if (force) {
     	this.prevResizeTriggerDims = {};
     }
     this.resizeTimer = setTimeout(function() {
        var w = $(window);
        if (that.prevResizeTriggerDims['h'] != w.height() || that.prevResizeTriggerDims['w'] != w.width()) {
            that.resizeLayout();
            that.dhxLayout.setSizes(!1);
            that.prevResizeTriggerDims['h'] = w.height();
            that.prevResizeTriggerDims['w'] = w.width();
        }
     }, 100);
   };
   this.resizeLayout = function() {
        if (this.forceSize['w'] && this.forceSize['h']) {
            if (this.layoutDiv.css('height') != this.forceSize['h']) this.layoutDiv.css('height', this.forceSize['h']);
            if (this.layoutDiv.css('width') != this.forceSize['w']) this.layoutDiv.css('width', this.forceSize['w']);
            return;
        }

       var w = $(window);

       // force a size a bit bigger to force a scrollbar, then reset it to fit within the window
       this.layoutDiv.css('height', (w.height() + 1) + 'px');
       this.layoutDiv.css('width', (w.width() + 1) + 'px');

       var p = this.layoutDiv.offset();
       var h = w.height() - p.top - this.bsub;
       if (this.minSize['h'] && h < this.minSize['h']) h = this.minSize['h'];

       var w = w.width() - p.left - this.rsub;
       if (this.minSize['w'] && w < this.minSize['w']) w = this.minSize['w'];

       if (this.forceSize['w']) w = this.forceSize['w'];
       if (this.forceSize['h']) h = this.forceSize['h'];

       this.layoutDiv.css('height', h + 'px').css('width', (w) + 'px');

       // do this again since we now have it without the scrollbar
       this.layoutDiv.css('height', h + 'px').css('width', (w) + 'px');
   };
   
   /*** tab templates ****/
   this.tabTemplate = function(name, params) {
       var tv = params['prefix'] || this._rndstr(10);
       var g = params['grid'];
       var p = params;
       var parentGrid = function() { return window[g]; }
       if (name == 'notes') {
           return {'title': 'Notes',
                   'name': tv + '_notes_tab',
                   'var':  tv + '_notes_tab',
                   'content': {
                       'type': 'grid',
                       'var':  tv + '_notes_grid',
                       'grid': {
                            fields: [
                                {'name':'Title','sort':'str','width':'150','align':'left','type':'rotxt','field':'Title','filter':'#textregex_filter','split':true},
                                {'name':'Body','sort':'str', 'width':'200', 'align':'left', 'type':'rotxt','field':'Body','filter':'#textregex_filter'},
                                {'name':'Added','sort':'date', 'width':'120', 'align':'center', 'type':'rotxt','field':'CreatedDate','filter':'#textregex_filter'},
                                {'name':'By','sort':'str', 'width':'150', 'align':'left', 'type':'rotxt','field':'CreatedById',related:'User',related_field:'CreatedBy.Name','filter':'#textregex_filter'}
                            ],
                            load_func: function(grid) {
                                grid.CF_resetGrid();
                                grid.CF_current_rec = parentGrid().getSelectedId();
                                if ($.isLiveId(grid.CF_current_rec)) {
	                              CF_beginProgress('Loading Notes');
                                  {!$RemoteAction.Configero_Framework.getNotesForObjectId}(grid.CF_current_rec, function(result, event) { grid.CF_genericSFLoadFunc(result, event); });
                                }
                            }
                       }
                   },
                   'toolbar': {
                          items: [
                          {
                              type: "button",
                              id: "add",
                              img: "Configero/add.png",
                              tooltip: 'Add',
                              onClick: function() {
                                  var idd = tv + '_notes_dialog';
                                  var url = CF_NAMESPACE_PREFIX + 'Configero_NewNote?dialog=' + tv + '_notes_dialog&grid=' + tv + '_notes_grid&id=' + escape(parentGrid().getSelectedId());
                                  $('#' + idd).html($('<iframe style="width: 100%; height: 100%; border: 0px" />').attr('src', url)).dialog('open');
                              }
                          },
		                    {
		                       type: "button",
		                       id: "refresh",
		                       img: "Configero/refresh.png",
		                       tooltip: 'Refresh',
		                       onClick: function() {
                                  var idd = tv + '_notes_grid';
                                  window[idd].load_func(window[idd]);
		                       }
		                    }
                          ]
                   },
                   'postInit': function(obj) {
                        // add the dialog holder for notes
                        var idd = tv + '_notes_dialog';
                        if ($('#' + idd).length == 0) {
	                          $('body').append($('<div class="hidden"></div>').attr('id', idd));
	                          $('#' + idd).dialog({modal: true, title: 'New Note', width: 400, height: 350, closeOnEscape: true, autoOpen: false});
	                     }

						var notes_grid = window[tv + '_notes_grid'];

	                    obj.CF_processed = false;
	                    obj.CF_onSelect = function() {
	                        if (obj.CF_processed) return;
	                        obj.CF_processed = true;
	                        notes_grid.load_func(notes_grid);
	                    }
	                    obj.CF_onunSelect = function() {
	                        if (!obj.CF_processed) return;
	                        obj.CF_processed = false;
	                        notes_grid.CF_resetGrid();
	                    }
	                    obj.CF_destroy = function() {
							if (notes_grid) {
								notes_grid.CF_destroy && notes_grid.CF_destroy();
								window[tv + '_notes_grid'] = false;
								obj.attachObject($('<div />').text('').get(0));
                        		obj.detachToolbar();
							}
	                    }
                   }
                 };
       } else if (name == 'attachments') {
           return {'title': 'Attachments',
                   'name': tv + '_attachments_tab',
                   'var':  tv + '_attachments_tab',
                   'content': {
                      'type': 'grid',
                      'var':  tv + '_attachments_grid',
                      'grid': {
                          fields: [
                            {'name':'Name','sort':'str','width':'200','align':'left','type':'link','field':'Name','value_func':function(rec){return (rec['ContentFileName'] ? rec['ContentFileName'] : rec['Name']) + '^/' + escape(rec['Id'])},'filter':'#textregex_filter,#textregex_filter','split':true},
                            {'name':'Size','sort':'int', 'width':'90', 'align':'left', 'type':'rotxt','field':'BodyLength','value_func':function(rec){return rec['ContentSize'] ? rec['ContentSize'] : rec['BodyLength'];},'filter':'#numeric_filter'},
                              {'name':'Uploaded','sort':'date', 'width':'120', 'align':'center', 'type':'rotxt','field':'CreatedDate','filter':'#textregex_filter'},
                              {'name':'By','sort':'str', 'width':'150', 'align':'left', 'type':'rotxt','field':'CreatedById',related:'User',related_field:'CreatedBy.Name','filter':'#textregex_filter'}
                          ],
                          load_func: function(grid) {
                              grid.CF_resetGrid();
                              grid.CF_current_rec = parentGrid().getSelectedId();
                              if ($.isLiveId(grid.CF_current_rec)) {
                                CF_beginProgress('Loading Attachments');
                                {!$RemoteAction.Configero_Framework.getAttachmentsForObjectId}(grid.CF_current_rec, function(result, event) { grid.CF_genericSFLoadFunc(result, event); });
                              }
                          }
                      }
                    },
                   'toolbar': {
                          items: [
                          {
                              type: "button",
                              id: "add",
                              img: "Configero/add.png",
                              tooltip: 'Add',
                              onClick: function() {
                                  var idd = tv + '_attachments_dialog';
                                  var url = CF_NAMESPACE_PREFIX + 'Configero_AttachmentUpload?dialog=' + tv + '_attachments_dialog&grid=' + tv + '_attachments_grid&id=' + escape(parentGrid().getSelectedId());
                                  $('#' + idd).html($('<iframe style="width: 100%; height: 100%; border: 0px" />').attr('src', url)).dialog('open');
                              }
		                    },
		                    {
		                       type: "button",
		                       id: "refresh",
		                       img: "Configero/refresh.png",
		                       tooltip: 'Refresh',
		                       onClick: function() {
                                  var idd = tv + '_attachments_grid';
                                  window[idd].load_func(window[idd]);
		                       }
		                    }
                          ]
                   },
                    'postInit': function(obj) {
                        // add the dialog holder for notes
                        var idd = tv + '_attachments_dialog';
                        if ($('#' + idd).length == 0) {
	                        $('body').append($('<div class="hidden"></div>').attr('id', idd));
	                        $('#' + idd).dialog({modal: true, title: 'Upload Attachment', width: 400, height: 350, closeOnEscape: true, autoOpen: false});
	                    }

                    	var attachments_grid = window[tv + '_attachments_grid'];

	                    obj.CF_processed = false;
	                    obj.CF_onSelect = function() {
	                        if (obj.CF_processed) return;
	                        obj.CF_processed = true;
	                        attachments_grid.load_func(attachments_grid);
	                    }
	                    obj.CF_onunSelect = function() {
	                        if (!obj.CF_processed) return;
	                        obj.CF_processed = false;
	                        attachments_grid.CF_resetGrid();
	                    }
	                    obj.CF_destroy = function() {
	                    	if (attachments_grid) {
								attachments_grid.CF_destroy && attachments_grid.CF_destroy();
								window[tv + '_attachments_grid'] = false;
								obj.attachObject($('<div />').text('').get(0));
                        		obj.detachToolbar();
							}
	                    }
                    }
                 };
        /*
        } else if (name == 'tasks') {
           return {'title': 'Tasks',
                   'content': {
                      'type': 'grid',
                      'var':  tv + '_tasks_grid',
                      'grid': {
                          fields: [
                            {'name':'Subject','sort':'str','width':'100','align':'left','type':'link','field':'Subject','filter':'#textregex_filter'},
                            {'name':'Date','sort':'date','width':'80','align':'left','type':'rotxt','field':'ActivityDate','filter':'#textregex_filter'},
                            {'name':'Related To','sort':'str','width':'100','align':'left','type':'link','field':'WhatId',related:'Name',related_field:'What.Name','filter':'#textregex_filter'},
                            {'name':'Assigned To','sort':'str','width':'100','align':'left','type':'link','field':'OwnerId',related:'User',related_field:'Owner.Name','filter':'#textregex_filter'},
                            {'name':'Description','sort':'str','width':'150','align':'left','type':'rotxt','field':'Description','filter':'#textregex_filter'},
                            {'name':'Status','sort':'str','width':'80','align':'left','type':'rotxt','field':'Status','filter':'#textregex_filter'}
                          ],
                          load_func: function(grid) {
                              grid.CF_resetGrid();
                              grid.CF_current_rec = parentGrid().getSelectedId();
                              if (!grid.CF_current_rec || grid.CF_current_rec == '') return;
                              CF_beginProgress('Loading Tasks');
                              if (!$.isTemporaryId(grid.CF_current_rec)) {
                                {!$RemoteAction.Configero_Framework.getTasksForObjectId}(grid.CF_current_rec, function(result, event) { grid.CF_genericSFLoadFunc(result, event); });
                              }
                          },
                      }
                    },
                   'toolbar': {
                          items: [
                          {
                              type: "button",
                              id: "add",
                              img: "Configero/add.png",
                              tooltip: 'Add',
                              onClick: function() {
                                  var idd = tv + '_tasks_dialog';
                                  var url = CF_NAMESPACE_PREFIX + 'Configero_NewTask?dialog=' + tv + '_tasks_dialog&grid=' + tv + '_tasks_grid&id=' + escape(parentGrid().getSelectedId());
                                  $('#' + idd).html($('<iframe style="width: 100%; height: 100%; border: 0px" />').attr('src', url)).dialog('open');
                              }
                          }
                          ]
                   },
                    'postInit': function(obj) {
                        // add the dialog holder for tasks
                        var idd = tv + '_tasks_dialog';
                          $('body').append($('<div class="hidden"></div>').attr('id', idd));
                          $('#' + idd).dialog({modal: true, title: 'New Task', width: 500, height: 400, closeOnEscape: true, autoOpen: false});

                        parentGrid().attachEvent('onRowSelect', function(id, ind) {
                            var nn = window[tv + '_tasks_grid'];
                            if (nn.CF_current_rec == id) return;
                            nn.load_func(nn);
                        });
                   }
                 };
       } else if (name == 'events') {
           return {'title': 'Events',
                   'content': {
                      'type': 'grid',
                      'var':  tv + '_events_grid',
                      'grid': {
                          fields: [
                            {'name':'Subject','sort':'str','width':'100','align':'left','type':'link','field':'Subject','filter':'#textregex_filter'},
                            {'name':'Assigned To','sort':'str','width':'100','align':'left','type':'link','type':'rotxt','field':'OwnerId',related:'User',related_field:'Owner.Name','filter':'#textregex_filter'},
                            {'name':'Description','sort':'str','width':'150','align':'left','type':'rotxt','field':'Description','filter':'#textregex_filter'},
                            {'name':'Start Date','sort':'date','width':'80','align':'left','type':'rotxt','field':'StartDateTime','filter':'#textregex_filter'},                            
                            {'name':'End Date','sort':'date','width':'80','align':'left','type':'rotxt','field':'EndDateTime','filter':'#textregex_filter'}
                          ],
                          load_func: function(grid) {
                              grid.CF_resetGrid();
                              grid.CF_current_rec = parentGrid().getSelectedId();
                              if (!grid.CF_current_rec || grid.CF_current_rec == '') return;
                              CF_beginProgress('Loading Events');
                              if (!$.isTemporaryId(grid.CF_current_rec)) {
                                {!$RemoteAction.Configero_Framework.getEventsForObjectId}(grid.CF_current_rec, function(result, event) { grid.CF_genericSFLoadFunc(result, event); });
                              }
                          },
                      }
                    },
                   'toolbar': {
                          items: [
                          {
                              type: "button",
                              id: "add",
                              img: "Configero/add.png",
                              tooltip: 'Add',
                              onClick: function() {
                                  var idd = tv + '_events_dialog';
                                  var url = CF_NAMESPACE_PREFIX + 'Configero_NewEvent?dialog=' + tv + '_events_dialog&grid=' + tv + '_events_grid&id=' + escape(parentGrid().getSelectedId());
                                  $('#' + idd).html($('<iframe style="width: 100%; height: 100%; border: 0px" />').attr('src', url)).dialog('open');
                              }
                          }
                          ]
                   },
                    'postInit': function(obj) {
                        // add the dialog holder for tasks
                        var idd = tv + '_events_dialog';
                          $('body').append($('<div class="hidden"></div>').attr('id', idd));
                          $('#' + idd).dialog({modal: true, title: 'New Event', width: 500, height: 400, closeOnEscape: true, autoOpen: false});

                        parentGrid().attachEvent('onRowSelect', function(id, ind) {
                            var nn = window[tv + '_events_grid'];
                            if (nn.CF_current_rec == id) return;
                            nn.load_func(nn);
                        });
                   }
                 };
       */
       } else if (name == 'chatter') {
           return {'title': 'Chatter',
                   'name': tv + '_chatter',
                   'var':  tv + '_chatter',
                   'content': {
                       'type': 'text',
                       'text': p['defaultText']
                   },
                   'postInit': function(obj) {
		               obj.CF_processed = false;
		               obj.CF_onSelect = function() {
		                   if (obj.CF_processed) return;
		                   obj.CF_processed = true;
		                   var id = parentGrid().getSelectedId();
		                   if (!id || id == '') {
		                      obj.CF_onunSelect();
		                   } else if ($.isTemporaryId(id)) {
		                   	obj.attachObject($('<div />').text('').get(0));
		                   } else {
		                       obj.attachURL($.CF_getApexURL(CF_NAMESPACE_PREFIX + 'Configero_Chatter?id=' + escape(id)));
		                   }
		               },
		               obj.CF_onunSelect = function() {
		                   if (!obj.CF_processed) return;
		                   obj.CF_processed = false;
		                   obj.attachObject($('<div />').text(p['defaultText']).get(0));
		               }
                   }
             };
       }
       /*
       } else if (name == 'detail_edit') {
           return {'title': 'Details',
                   'content': {
                       'type': 'html',
                       'html': '<span class="content">' + $.escapeHTML(p['defaultText']) + '</span>'
                   },
                   'postInit': function(obj) {
                       parentGrid().attachEvent('onRowSelect', function(id, ind) {
                             var h = $('.content', $(obj));
                             var tmpl = p['tmpl'];
                             if (typeof(p['tmpl']) == 'function') tmpl = p['tmpl'](parentGrid(), id);
                             if (tmpl == null) {
                                 h.text(p['defaultText']);
                                 return;
                             }
                             h.html($('#' + tmpl).html());

                             // replace plist selects with proper drop down options
                             $('select[plist]', h).each(function() {
                                 var t = $(this);
                                 $.addPlistOptionsToSelect(t, t.attr('plist'));
                             });

                             var inps = h.find(':input');
                             var lbls = h.find('span[field]');
                             var pg = parentGrid();

                             // TODO - handle checkboxes, radio, labels (things that we don't necessarily set the value for)
                             if (!pg.isPendingId(id)) inps.filter('[name="Id"]').val(id);
                             for (var i = 0; i < pg.field_def.length; i++) {
                                 var cval = pg.cells(id, i).getValue();
                                 inps.filter('[name="' + pg.field_def[i]['field'] + '"]').val(cval);
                                 lbls.filter('[field="' + pg.field_def[i]['field'] + '"]').text(cval);
                             }

                             // add the hook to the SaveBtn class to save this record
                             $('.SaveBtn').click(function() {
                                 CF_beginProgress('Saving');
                                 var sf = remoter[$(this).attr('saveFunc')];
                                 sf($(this).closest('form').serializeObject(), function(result, event) {
                                      if (event.status == true) {
                                          // result is the new Id
                                          var idd = pg.getSelectedId();
                                          if (idd != result) {
                                              pg.changeRowId(idd, result);
                                              idd = result;
                                          }

                                          // update value from form to grid
                                          for (var i = 0; i < pg.field_def.length; i++) {
                                              // TODO - handle checkboxes, radio, labels (same as before)
                                              var fld = inps.filter('[name="' + pg.field_def[i]['field'] + '"]');
                                              if (fld.length > 0) {
                                                  pg.cellById(idd, i).setValue(fld.val());
                                              }

                                              fld = lbls.filter('[field="' + pg.field_def[i]['field'] + '"]');
                                              if (fld.length > 0) {
                                                  pg.cellById(idd, i).setValue(fld.text());
                                              }
                                          }

                                          // retrigger grid click event
                                          pg.callEvent('onRowSelect', [idd]);
                                      } else {
                                          alert(event.message);
                                      }
                                      CF_endProgress();
                                 }, {escape: false});
                             });

                             if (p['postRenderFunc']) p['postRenderFunc'](h, parentGrid(), p);
                        });
                    }
              };
       }
       */
   };

   /*
   this.lookupGenericSelectFunction = function(idField, lblField) {
       return function(id, lbl) {
           idField.val(id);
           lblField.text(lbl);
           that.lookupDialog.dialog('close');
       }
   }
   */
 };

 var __cf = new CF_layoutManager();

 function CF_beginProgress(title, withProgress) {
     CF_totalProgressWindows++;
    if (title == undefined) title = '';
    $('#CF_progressBar').progressbar({value: 0});
    if (withProgress) $('#CF_progressBar').show();
    else $('#CF_progressBar').hide();

    $('#CF_progressFunction').text(title);
    $('#CF_progressCustomMessage').text('');
    $('#CF_progressDialog').dialog('open');
 };
 function CF_doWhenIdle(func) {
    // do this in a timeout in case we end progress within a current thread...we really want to wait till the thread is finished
    // do this at setTimeout 50 since things like saveRecs uses 10 - we want to do it after everything else is done
    window.setTimeout(function() {
    	if (CF_isIdle()) {
            func();
        } else {
            CF_progressCompleteQueue.push(func);
        }
    }, 50);
 }
 function CF_isIdle() {
 	return !$("#CF_progressDialog").dialog('isOpen');
 }
 function CF_endProgress() {
    CF_totalProgressWindows--;
    if (CF_totalProgressWindows == 0) {
        if (CF_progressCompleteQueue.length > 0) {
            // we assume everything that happens with the queue will be done using progress windows
            // so that when they finish, the next one can run
            (CF_progressCompleteQueue.shift())();
        } else {
            var dlg = $('#CF_progressDialog');
            if (dlg.dialog('isOpen')) dlg.dialog('close');
        }
    } else if (CF_totalProgressWindows < 0) {
        // set it back to 0 - this extra call happens with things like the attachment upload that show the progress sometimes but hide on each load
        CF_totalProgressWindows = 0;
        //alert('CF_totalProgressWindows < 0?');
    }
 }
 function CF_getPagePreference(func) {
   CF_beginProgress('Loading Page Preferences');
   {!$RemoteAction.Configero_Framework.getPagePreferences}($.getPageBaseName(), function(result, event) {
        var x = {};
        if (result && result.length) {
            for (var i = 0; i < result.length; i++) {
                x[result[i].Name] = {dim: result[i][CF_NAMESPACE_PREFIX + 'Width__c'], collapsed: result[i][CF_NAMESPACE_PREFIX + 'SplitAt__c']};
            }
        }
        if (func) func(x);
        CF_endProgress();
   }, {escape: false});
 }
 $(function() {
    var w = $(window);
    var maxW = w.width() - 50;
    var maxH = w.height() - 25;

    $('#CF_progressBar').progressbar();
    $('#CF_progressDialog').dialog({modal: true, closeOnEscape: false, autoOpen: false, open: function(event, ui) { $(this).parents('.ui-dialog:first').find('.ui-dialog-titlebar-close').hide(); } });
    $('#CF_lookupDialog').dialog({modal: true, closeOnEscape: true, autoOpen: false, width: Math.min(800, maxW), height: Math.min(550, maxH)});
    $('#CF_vfDialog').dialog({modal: true, closeOnEscape: true, autoOpen: false, width: Math.min(600, maxW), height: Math.min(450, maxH), buttons: { 'Continue': function() { $(this).parents('.ui-dialog:first').find('iframe').get(0).contentWindow.saveData(); }, 'Cancel': function() { $(this).dialog('close'); } } });
    $('#CF_chatterFileSelectDialog').dialog({modal: true, closeOnEscape: true, autoOpen: false, width: Math.min(950, maxW), height: Math.min(550, maxH)});
 });
</script>

<form target="_blank" id="csvdownload_form" method="post" style="display: none">
<textarea id="csvdownload_formdata" name="d"></textarea>
<textarea id="csvdownload_type" name="type"></textarea>
<textarea id="csvdownload_name" name="name"></textarea>
</form>

<div id="CF_progressDialog" class="hidden">
    <span id="CF_progressFunction"></span>...<span id="CF_progressCustomMessage"></span>
    <div id="CF_progressBar"></div>
</div>

<div class="hidden" id="CF_lookupDialog"></div>
<div class="hidden" id="CF_vfDialog"></div>
<div class="hidden" id="CF_chatterFileSelectDialog"></div>

<apex:form styleClass="hidden">
<div id="cfTmplNumber"><apex:inputField value="{!object_template.PowerLoader__NumberTemplate__c}" /></div>
<div id="cfTmplDate"><apex:inputField value="{!object_template.PowerLoader__DateTemplate__c}" /></div>
</apex:form>

</apex:component>